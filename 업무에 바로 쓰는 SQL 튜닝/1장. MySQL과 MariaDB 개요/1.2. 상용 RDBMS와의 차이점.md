# 1장. MySQL과 MariaDB 개요
- MySQL과 MariaDB의 탄생 과정
  - MySQL은 1995년 오픈소스로 배포된 무료 DBMS이다.
  - 대용량 데이터와 가용성 안정성이라는 장점에 힘입어 배포 초기부터 학계는 물론 업계에서 다양한 용도로 활용되어 온 대중적인 소프트웨어이다.
  - 2010년 MySQL이 오라클에 인수된 뒤 2021년 6월 MySQL 8.0 버전까지 배포되었으며 상용 버전과 커뮤니티 버전으로 구분한다.
- 한편 MySQL이 오라클로 인수되고 나서 개발 지침과 라이선스 정책의 변화에 따라 MySQL의 핵심 개발자 주도로 오픈소스 정책을 지향하는 MariaDB가 탄생했다.
  - MariaDB는 MySQL의 소스 코드에 기반을 두고 개발된 만큼, SQL 문을 사용하는 개발자 입장에서 현재까지 별다른 차이는 없다.
  - 물론 일부 기능과 수행 메커니즘, 시스템 변수(system variable)나 시스템 상태(system status) 등에서 점점 차이가 나고 있기는 하지만 SQL 문의 주요 뼈대는 크게 다르지 않다.
- 버전 측면에서는 MySQL과 MariaDB 모두 초반에 5.x 버전으로 같은 길을 가는 건가 했으나 5.5 버전부터 MariaDB가 독자적인 길을 선택하면서 두 갈래로 나뉘게 되었다.
  - SQL 문을 개발하는 입장에서 버전에 따른 기능 차이가 존재하지만 작성하는 SQL 문의 문법이나 실행 계획의 출력 방식은 유사하므로 버전과 관계없이 SQL 문을 개발할 수 있다.
  - 단, 버전에 따라 DB 엔진 레벨에서 제공하는 옵티마이저 기능의 차이는 존재하므로 데이터베이스 관리자라면 해당 부분을 염두해야 한다.

## 1.2. 상용 RDBMS와의 차이점
- 오픈소스인 MySQL 및 MariaDB와 국내 시장 점유율이 가장 높은 상용DB인 오라클을 기준으로 각각의 구조와 기능 그리고 SQL 문을 간단히 비교, 분석 하겠다.

### 1.2.1. 구조적 차이
- 오라클과 MySQL을 실제 서비스에 도입할때는 장애 예방 효과 또는 장애 발생 시에 가용성을 기대하며 이중화 구조로 구축한다.
  - 나아가 삼중화 이상의 다중화 구조로 구축하여 가용성 수준을 더 높일 수 있다.
- 기본적으로 데이터가 저장되는 스토리지의 구조 측면에서 큰 차이를 보인다.
  - 오라클 DB는 통합된 스트리지 하나를 공유(shared everything)하여 사용하는 방식이지만, MySQL은 물리적인 DB 서버마다 독립적으로 스토리지를 할당(shared nothing)하여 구성한다.
  - 물론 DBMS마다 서드 파티 제품을 이용하여 응용 구조를 변경할 수도 있지만, 위의 예시는 가장 대중적으로 구축하는 예시이다.
- 오라클은 공유 스토리지를 사용하므로 사용자가 어느 DB 서버에 접속하여 SQL 문을 수행하더라도 같은 결과를 출력하거나 동일한 구문(SELECT, INSERT, DELETE, UPDATE)을 처리할 수 있다.
- 반면, MySQL은 독립적인 스토리지 할당에 기반을 두는 만큼 이중화를 위한 클러스터(cluster)나 복제(replication) 구성으로 운영하더라도 보통은 마스터-슬레이브(master-slave) 구조(주-종 구조)가 대부분이다.
  - 물론 마스터-마스터(master-master) 구조로도 구축할 수 있지만 상대적으로 적은 사례에 해당한다.
  - 이때 마스터 노드는 쓰기/읽기 처리를 모두 수행할 수 있고 슬레이브 노드는 읽기 처리만 수행할 수 있다.
  - 즉, 물리적으로 여러 대의 MySQL DB 서버에 접속하더라도 동일한 구문(SELECT, INSERT, DELETE, UPDATE)이 처리되지 않을 수 있으며 DB 서버마다 각자의 역할이 부여될 수 있따.
    - 이는 SQL 튜닝과는 거리가 있는 내용처럼 들릴 수 있으나, 쿼리문이 수행하는 서버의 위치를 파악하고 튜닝을 진행하면 물리적인 위치 특성이 내포된 쿼리 튜닝을 수행할 수 있다.
- 마스터-슬레이브 구조로 구축한 두 대의 MySQL 서버를 보자.
  - 애플리케이션을 통해 쿼리 오프로딩(query offloading)이 적용되므로 마스터 노드에서는 UPDATE, INSERT, DELETE 문을 수행하고 슬레이브 노드에서는 SELECT 문을 수행한다.
  - 만약 SELECT 문에 대한 쿼리 튜닝을 마스터 노드에서 수행하거나, UPDATE 문에 대한 쿼리 튜닝을 슬레이브 노드에 접속해서 수행한다면 어떻게 될까?
    - 정상적인 쿼리 튜닝 결과가 도출되지 않을 것이다.
    - 이와 같은 잘못된 결과는 쿼리가 수행되는 물리적인 서버의 위치를 인지하고 쿼리 튜닝을 수행한다면 발생하지 않을 것이다.
  - 즉, 구축된 DB 서버의 구조를 충분히 이해하고 적합한 서버(Master 또는 Slave 서버)에 접근하여 쿼리 튜닝을 수행하는 일은 매우 중요하다.
  - 다만, 각 DB 서버의 운영체제 설정, 할당된 스토리지 크기, 시스템 변수, 하드웨어 사양 등이 같을 때는 마스터 노드 중심으로 쿼리 튜닝을 진행해도 무방하다.
> #### 쿼리 오프로딩
> - DB 서버의 트랜잭션에서 쓰기(write) 트랜잭션과 읽기(read) 트랜잭션을 분리하여 DB 처리량을 증가시키는 성능 향상 기법이다.
>   - **쓰기 트랜잭션** : UPDATE, INSERT, DELETE
>   - **읽기 트랜잭션** : SELECT

### 1.2.2 지원 기능 차이
- MySQL과 오라클 DB에서 제공하는 조인 알고리즘(join algorithm)의 기능에는 차이가 있다.
  - MySQL은 대부분 중첩 루프 조인(nested loop join) 방식으로 조인을 수행하는 한편, 오라클에서는 중첩 루프 조인 방식뿐만 아니라 정렬 병합 조인(sort merge join)과 해시 조인(hash join) 방식도 제공한다.
  - 최근에는 더 효율적으로 쿼리를 수행하고자 MySQL 8.0.18 버전에서도 제약적으로 해시 조인을 제공하지만 여전히 대부분의 조인은 중첩 루프 조인으로 풀린다.
- 특히 MySQL은 오라클과 달리 데이터를 저장하는 스토리지 엔진이라는 개념을 포함하므로 오픈소스 DBMS를 바로 꽂아서 사용할 수 있는 확장성이 특징이다.
  - 일명 DBMS의 플러그 앤 플레이(plug & play)라는 기능이다.
  - 또한 MySQL은 오라클 대비 메모리 사용률이 상대적으로 낮으므로 사양이 낮은 컴퓨팅 환경에서도 설치하여 서비스할 수 있다.
  - 심지어 1MB 메모리 환경에서도 데이터베이스를 운영할 수 있을 만큼 오버헤드가 작지만, 오라클은 최소 수백 MB의 환경이 제공되어야 설치할 수 있다.

> #### MySQL 정리
> 1. 주로 중첩 루프 조인 알고리즘만으로 풀린다.
> 2. 필요한 DBMS를 설정해 사용할 수 있다.
> 3. 상대적으로 낮은 메모리 사용으로 저사양 PC에서도 손쉽게 설치 및 개발할 수 있다.

### 1.2.3 SQL 구문 차이
- SQL 구문 차이에 대해 알아보자.
  - 자주 사용하는 오라클 함수명이나 문법이 MySQL과는 조금 다르므로 SQL 튜닝을 수행하기 전에 기본적인 SQL 구문 특성을 이해해야 한다.

> #### Null 대체
> - 
> - MySQL/MariaDB
>   - IFNULL(열명, '대쳇값')
> - 오라클
>   - NVL(열명, '대쳇값')

> #### 페이징 처리
> - 테이블에서 데이터를 불러올 경우 전체가 아닌 일부 분량만 제한적으로 가져올 때가 있다.
>   - 해당 키워드는 페이징 처리뿐만 아니라 새 일련번호를 받는 순번을 생성할 때도 응용하여 사용할 수 있다.
> - MySQL/MariaDB
>   - LIMIT 숫자
> - 오라클
>   - ROWNUM <= 숫자

> #### 현재 날짜
> - DBMS의 현재 시스템 날짜를 조회할 때, MySQL에서는 NOW() 함수를 사용하고 오라클에서는 SYSDATE 키워드를 사용한다.
>   - 물론 MySQL에서 SYSDATE() 함수를 사용할 수 있으나 다수의 SYSDATE() 함수를 사용하면 함수의 호출 시점을 출력하는 특성으로 상이한 값이 출력된다.
>   - 이에 단위 쿼리를 기준으로 동일한 결과값을 출력하는 MySQL의 Now() 함수와 오라클의 SYSDATE 함수를 기준으로 알아보자.
> - MySQL/MariaDB
>   - NOW()
> - 오라클
>   - SYSDATE

> #### 조건문
> - 조건문이란 특정한 조건을 만족할 때와 만족하지 않을 때 각각 수행할 방향을 정해주는 구문이다.
>   - MySQL에서는 일반적인 프로그래밍에서 사용하는 키워드인 IF 문과 CASE WHEN~THEN 문을 사용하며 오라클에서는 DECODE 키워드, CASE WHEN~THEN 문을 사용한다.
> - MySQL/MariaDB
>   - IF(조건식, '참값', '거짓값')
> - 오라클
>   - DECODE(열명, '값', '참값', '거짓값)

> #### 날짜 형식
> - 날짜 데이터를 원하는 형태로 변경하는 구문을 작성하 수 있다.
> - MySQL/MariaDB
>   - DATE_FORMAT(날짜열, '형식')
> - 오라클
>   - TO_CHAR(날짜열, '형식')

> #### 자동 증갓값
> - 신규 데이터가 지속해 생성될 때는 증가하는 순번을 자동으로 매기는 숫자형 값, 즉 자동 증갓값을 저장할 수 있다.
>   - 이미 저장된 다른 데이터와 값이 중복되지 않도록 기존에 저장된 순번보다 더 큰 숫자를 생성하여 데이터를 저장하는 방식이다.
> - 이때 MariaDB와 오라클에서는 각각 시퀀스(sequence)라는 오브젝트(object)를 활용한다. (단, 오라클 시퀀스는 기존 데이터보다 작은 값으로 순번을 매길 수도 있다.)
>   - 먼저 CREATE SEQUENCE 문으로 시퀀스 오브젝트를 생성한 뒤, 해당 시퀀스 명으로 함수를 호출하여 신규 숫자를 채번할 수 있다.
>   - 이때 SELECT 시퀀스명.nextval FROM dual; 구문으로 신규 데이터의 시퀀스 숫자를 가져온다.
> - 한편 MySQL에서는 두 가지 방법으로 자동 증갓값을 저장한다.
>   - 첫 번째는 특정 열의 속성으로 자동 증가하는 값을 설정하는 auto_increment를 명시하는 방법이다.
>     - 즉, 테이블 마다 특정한 하나의 열에만 해당 속성을 정의하여 자동 증가하는 숫자를 저장할 수 있다.
>   - 두 번째는 (MariaDB 10.3 이상일 때만) 오라클과 마찬가지로 시퀀스라는 오브젝트를 생성한 뒤 호출하여 활용하는 방법이다.
>     - 구체적으로 CREATE SEQUENCE 문으로 시퀀스를 생성한 뒤 SELECT nextval (시퀀스명); 구문으로 신규 순번을 매기는 기능을 활용할 수 있다.
> - MySQL
>   - AUTO_INCREMENT 
> - MariaDB 10.3 이상
>   - SELECT NEXTVAL(시퀀스명);
> - 오라클
>   - SELECT 시퀀스명.NEXTVAL FROM dual;

> #### 문자 결합
> - 여러 개의 문자를 하나로 결합하여 조회할 때가 있다.
> - MySQL/MariaDB
>   - CONCAT(열값 또는 문자열, 열값 또는 문자열)
> - 오라클
>   - 열값 또는 문자열 || 열값 또는 문자열
>   - CONCAT(열값 또는 문자열, 열값 또는 문자열)

> #### 문자 추출
> - 무자열에서 특정 구간 및 특정 위치의 문자열을 추출하고 싶을 때가 있다.
> - MySQL/MariaDB
>   - SUBSTRING(열값 또는 문자열, 시작 위치, 추출하려는 문자 개수)
> - 오라클
>   - SUBSTR(열값 또는 문자열, 시작 위치, 추출하려는 문자 개수)

---