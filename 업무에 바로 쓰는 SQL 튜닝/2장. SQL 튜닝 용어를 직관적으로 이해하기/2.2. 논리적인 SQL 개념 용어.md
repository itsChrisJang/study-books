# 2장. SQL 튜닝 용어를 직관적으로 이해하기
- SQL 튜닝에 앞서 기본적으로 알아야 할 용어를 짚고 넘어가자.
- 튜닝을 수행하는 과정에서 DBMS의 전반적인 구조와 메커니즘에 기반을 둔 종합적 사고를 필요한 만큼 현업에서 통용되는 기본적인 용어는 반드시 알고 있어야 한다.

## 2.2. 논리적인 SQL 개념 용어
- 이 절에서는 SQL 문 작성에 필요한 주변 오브젝트와 SQL 문의 상호관계, 연관성과 알고리즘에 관한 논리적 개념 용어를 다룬다.
  - 그리고 개념을 직관적으로 이해할 수 있도록 학생 테이블과 지도교수 테이블의 예제를 살펴보자.
- 학생 테이블에는 학번, 이름, 전공코드 열이 있고 지도교수 테이블에는 학번과 지도교수명 열이 있다.
  - 두 테이블은 서로 일대일 관계이다.
  - 즉, 1명의 학생은 1명의 교수에게만 소속되며 1명의 교수는 1명의 학생만 지도할 수 있는 환경이다.

#### 학생 테이블
| 학번    | 이름   | 전공코드  |
|-------|------|-------|
|  |   ||

#### 지도교수 테이블
| 학번 | 이름   |
|----|------|
|  |   |

### 2.2.1. 서브쿼리 위치에 따른 SQL 용어
- 서브쿼리(subquery)란 쿼리 안의 보조쿼리를 가리키는 용어디ㅏ.
  - 가장 바깥쪽의 SELECT 문인 메인쿼리(main query)를 기준으로 내부에 SELECT 문을 추가로 작성해서 서브쿼리를 만든다.
  - 이처럼 SELECT 문 안쪽에 위치한 SELECT 문은 어느 위치에 작성되었는지에 따라 부르는 용어가 달라진다.
  - 작성하는 위치는 크게 SELECT 절, FROM 절, WHERE 절로 나뉜다.
- 다음 쿼리는 SELECT 절, FROM 절, WHERE 절로 작성한 메인쿼리(=외부쿼리 outer query) 입니다.
  - (1)은 주로 메인쿼리의 SELECT 절 내부에 하나의 숫자나 문자, 기호 등을 출력하는 SELECT 문으로 스칼라 서브쿼리(scalar subquery) 라고 한다.
  - (2)는 메인쿼리의 FROM 절 내부에 작성한 SELECT 문으로 인라인 뷰(inline view) 라고 한다.
  - (3)은 메인쿼리의 WHERE 절 내부에 작성한 SELECT 문으로 중첩 서브쿼리(nested subquery) 라고 부른다.

```sql
SELECT (SELECT ... FROM ...)            <---- (1) SELECT 절 : 스칼라 서브쿼리
  FROM (SELECT ... FROM ...)            <---- (2) FROM 절 : 인라인 뷰
 WHERE 컬럴명 IN (SELECT ... FROM ...)    <---- (3) WHERE 절 : 중첩 서브쿼리
```

#### 스칼라 서브쿼리
- 메인쿼리의 SELECT 절에 있는 또 다른 SELECT 절이 스칼라 서브쿼리라고 앞서 설명했다.
  - 사실 FROM 절이나 WHERE 절 등에서도 스칼라 서브쿼리를 사용할 수 있으나, 대부분의 SQL 문에서 SELECT 절을 사용하므로 본 내용에서도 SELECT 절에 작성된 SELECT 문을 기준으로 설명한다.
  - 메인쿼리의 SELECT 절에는 최종 출력하려는 열들이 나열되므로, 출력 데이터 1건과 스칼라 서브쿼리의 결과 건수가 일치해야 한다.
  - 만약 스칼라 서브쿼리의 결괏값이 2개 이상 나온다면 에러가 발생할 것이다.
  - 즉, 스칼라 서브쿼리의 결괏값은 1행 1열의 구조로 출력되어야 한다.
- 다음은 학생 테이블에서 이름 데이터와 스칼라 서브쿼리의 결괏값을 출력하는 SQL 문이다.
  - 학생 1명의 이름당 스칼라 서브쿼리 결과가 1건만 출력되는 count(*)를 써서 작성했다.
  - 보통 스칼라 서브쿼리는 출력되는 데이터 건수가 1건이어야 하므로 집계함수(max, min, avg, sum, count 등)가 자주 쓰인다.
```sql
SELECT 이름,
       (SELECT COUNT(*)
          FROM 학생 AS 학생2
         WHERE 학생2.이름 = 학생1.이름) 카운트
  FROM 학생 AS 학생1;
```

#### 인라인 뷰
- 메인쿼리의 FROM 절에 있는 또 다른 SELECT 절이 인라인 뷰라고 설명했다.
  - FROM 절 내부에서 일시적으로 뷰를 생성하는 방식이므로 인라인 뷰라고 불린다.
  - 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성하여 활용한다.
```sql
SELECT 학생2.학번, 학생2.이름
  FROM (SELECT *
          FROM 학생
         WHERE 성별 = '남') 학생2;
```

#### 중첩 서브쿼리
- 메인쿼리의 WHERE 절에 있는 또 다른 SELECT 절을 중첩 서브쿼리라고 앞서 설명했다.
  - WHERE 절에서 단순한 값을 비교 연산하는 대신, 서브쿼리를 추가하여 비교 연산하기 위해 중첩 서브쿼리를 사용한다.
  - 이처럼 WHERE 절에서 중첩 서브쿼리와 비교할 때는 보통 비교 연산자(=, <, >, <=, >=, <>, !=)를 비롯해 IN, EXISTS, NOT IN, NOT EXISTS 문을 많이 사용한다.
```sql
SELECT *
  FROM 학생 
 WHERE 학번 = (SELECT MAX(학번)
                FROM 학생)
```

### 2.2.2. 메인쿼리와의 관계성에 따른 SQL 용어
- 서브쿼리와 메인쿼리의 관계성에 따른 SQL 용어에 대해 알아보자.
  - 서브쿼리는 그 자체가 독립적인 형태로 존재할 수도 있고 메인쿼리와 끈끈한 관계를 유지하며 존재할 수 있다.

#### 비상관 서브쿼리
- 비상관 서브쿼리(non correlated subquery)는 메인쿼리와 서브쿼리 간에 관계성이 없음을 의미한다.
  - 서브쿼리가 독자적으로 실행된 뒤 메인쿼리에게 그 결과를 던져주는 형태이다.
- 요약하자면, 비상관 서브쿼리에서는 서브쿼리가 먼저 실행된 뒤에 그 결과를 메인쿼리가 활용한다.
  - 즉, **서브쿼리 실행 -> 메인쿼리** 실행의 순서로 실행된다.
- 다음 예제의 비상관 서브쿼리는 **성별 = '남'** 조건으로 학생 테이블에서 데이터를 가져온 그 결과를 메인쿼리의 학생 테이블로 전달하여 최종 데이터를 출력한다.
  - 이때 DB 버전 및 옵티마이저에 따라 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합(view merging), 즉 SQL 재작성(rewrite)이 작동할 수 도 있다.
```sql
SELECT *
  FROM 학생 
 WHERE 학번 = (SELECT 학번
                FROM 학생
               WHERE 성별 = '남')
```

#### 상관 서브쿼리
- 상관 서브쿼리(correlated subquery)는 메인쿼리와 서브쿼리 간에 관계성이 있음을 의미한다.
  - 서브 쿼리가 수행되려면 메인쿼리의 값을 받아야 하므로 서브쿼리와 메인쿼리는 서로 끈끈한 관계를 유지한다.
  - 이러한 상관 서브쿼리는 SELECT 절에 작성하는 스칼라 서브쿼리와 WHERE 절에 작성하는 중첩 서브쿼리일 때 발생한다.
- 다음 예시에서는 지도교수 테이블에 대한 서브쿼리가 메인쿼리의 **학생.학번** 을 명시함으로써 그 관계성을 뚜렷하게 보여준다.
  - 메인쿼리에서 학생.학번 데이터를 전달받은 뒤 서브쿼리가 수행되고, 그 결과를 다시 메인쿼리로 전달한다.
```sql
메인쿼리 = 외부 쿼리
  SELECT ...
    FROM 학생 
   WHERE ... IN 
 
서브쿼리 = 내부쿼리
               (SELECT ...
                  FROM 지도교수
                 WHERE 학생.학번 = ...)
```
- 구체적으로는 먼저 메인쿼리에서 학생 테이블의 한번 결과를 서브쿼리로 전달한 뒤 지도교수 테이블의 학번과 비교(**지도교수.학번 = 학생.학번**)합니다.
  - 즉, 지도교수 테이블의 학번과 학생 테이블의 학번이 동일할 때만 서브쿼리의 결과로서 도출한다.
  - 이렇게 도출된 서브쿼리의 학번 결과를 메인쿼리의 학번과 비교해 최종 결과를 출력한다.
  - 즉, 전체적인 수행 순서는 **메인 쿼리 실행(학생.학번 데이터 가져오기) -> 서브쿼리 실행(지도교수.학번 = 학생.학번) -> 다시 메인쿼리 실행한 뒤 결과 출력(SELECT * FROM 학생 ~)** 과 같습니다.
  - 다만 이때도 DB 버전 및 옵티마이저에 따라 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합, 즉 SQL 재작성으로 작동할 수 있다.

### 2.2.3. 반환 결과에 따른 SQL 용어
- 서브쿼리의 결과 유형은 수치적 기준으로 구분할 수 있다.
  - 단순히 1건의 행 데이터만 반환하는 경우와 2개 이상의 행 데이터를 반환하는 경우, 그리고 2개 이상의 행과 열 데이터를 반환하는 경우로 정리한다.
  
#### 단일행 서브쿼리
- 단일행 서브쿼리(single-row subquery)는 서브쿼리 결과가 1건의 행으로 반환되는 쿼리이다.
  - 그에 따라 메인쿼리의 조건절에서는 =, <, > 등의 연산자와 비교한다.
  - 이러한 단일행 서브쿼리는 주로 SELECT 절에서 사용하는 스칼라 서브쿼리와 동일하다고 볼 수 있다.
- 다음의 단일행 서브쿼리 예제는 학생 테이블에서 학번의 최댓값을 조회하므로 항상 하나의 값만 반환된다.
  - 그 뒤에 메인쿼리가 수행되고 최종 결과가 출력된다.
```sql
  SELECT ...
    FROM ... 
   WHERE 학번 IN 서브쿼리
               (SELECT MAX(학번)
                  FROM 학생)  ----> 출력값이 하나인 서브쿼리
```

#### 다중행 서브쿼리
- 다중행 서브쿼리(multiple-row subquery)는 서브쿼리 결과가 여러 건의 행으로 반환되는 쿼리이다.
  - 그에 따라 메인쿼리의 조건절에서는 IN 구문으로 서브쿼리에서 반환되는 값들을 받는다.
- 다음의 다중행 서브쿼리 예제는 학생 테이블에서 전공코드별 학번 최댓값을 반환하므로 전공 코드의 종류만큼 학번의 최댓값들이 반환된다.
  - 이후 메인쿼리가 수행되고 최종 결과가 출력된다.
```sql
  SELECT ...
    FROM ... 
   WHERE 학번 IN 서브쿼리
               (SELECT MAX(학번)
                  FROM 학생
                 GROUP BY 전공코드)  ----> 출력값이 2개 이상인 서브쿼리
```

#### 다중열 서브쿼리
- 다중열 서브쿼리(multiple-column subquery)에서는 서브쿼리 결과가 여러 개의 열과 행으로 반환된다.
  - 그에 따라 메인쿼리의 조건절엥서는 IN 구문과 함께 서브쿼리에서 반환될 열들을 동일하게 나열해 서브쿼리 결과를 받습니다.
- 다음의 다중열 서브쿼리 예제는 학생 테이블에서 이름이 '김'으로 시작하는 학생의 이름과 전공코드를 반환하고, 메인쿼리에서는 반환되는 열들과 동일하게 **WHERE (이름, 전공코드) IN** 구문으로 서브쿼리 결과를 받는다.
  - 이후 메인쿼리가 수행되고 최종 결과를 출력한다.
```sql
  SELECT ...
    FROM ... 
   WHERE (이름, 전공코드) 
            IN 서브쿼리
               (SELECT 이름, 전공코드
                  FROM 학생
                 WHERE 이름 LIKE '김%') ---> 출력값으로 2개 이상의 컬럼을 출력하는 서브쿼리
```

### 2.2.4. 조인 연산방식 용어
- DB에는 다수의 테이블이 있고 필요한 데이터도 여기저기 흩어져 있다.
  - 이때 필요한 데이터끼리 결합할 때 조인(join)이라는 방식을 사용한다.
  - 분리된 데이터 간의 공통된 정보, 즉 동일한 열값 또는 키값 기준으로 데이터를 논리적으로 연결할 수 있다.
- 내부 조인(inner join)은 양쪽 테이블에 같은 데이터가 있을 때만 결합하는 방식이며 왼쪽 외부 조인(left outer join)과 오른쪽 외부 조인(right outer join)은 각각 어느 한쪽에만 데이터가 있어도 데이터를 결합하는 방식이다.
  - 어느 한쪽에도 해당 사항이 없을 때는 전체 외부 조인(full outer join)이라 한다.
- 학생 테이블과 지도 교수 테이블은 기본적으로 일대일 관계를 유지하며, 지도교수 확정되지 않은 학생은 지도교수 테이블에 해당 학번이 없을 수 있고, 자퇴한 학생의 정보는 지도교수 테이블에 데이터가 아직 남아있을 수 있다.
#### 학생 테이블
| 학번  | 이름   | 성별  |
|-----|------|-----|
| 1   | 이순신  | 남   |
| 2   | 신사임당 | 여   |
| 3   | 유재석  | 남   |
| 4   | 강감찬  | 여   |

#### 지도교수 테이블
| 학번  | 지도교수명 |
|-----|-------|
| 1   | 이황    |
| 2   | 세종대왕  |
| 4   | 김유신   |
| 99  | 이황    |

#### 내부 조인
- 내부 조인(inner join)은 말 그대로 교집합에 해당하는 방식으로, 양쪽에 모두 존재하는 데이터만 반환한다.
- 내부 조인을 명시적 조인으로 표현한 SQL 문은 다음과 같다.
  - JOIN 키워드에는 조인 대상 테이블을 작성하고 ON 절에는 조인할 비교조건을 작성한다.
```sql
  SELECT 학생.학번, 학생.이름, 지도교수.교수명
    FROM 학생
    JOIN 지도교수
      ON 학생.학번 = 지도교수.학번
```
- 다음은 내부 조인에 대해 눈에 보이지 않는 암시적 조인으로 SQL 문을 작성한 예제이다.
```sql
  SELECT 학생.학번, 학생.이름, 지도교수.교수명
    FROM 학생, 지도교수
   WHERE 학생.학번 = 지도교수.학번
```
| 학번  | 이름   | 교수명  |
|-----|------|------|
| 1   | 이순신  | 이황   |
| 2   | 신사임당 | 세종대왕 |
| 4   | 강감찬  | 김유신  |

#### 왼쪽 외부 조인
- 왼쪽 외부 조인(left outer join)은 왼쪽 테이블(먼저 작성된 테이블) 기준으로 오른쪽 테이블(나중에 작성된 테이블)과 조인을 수행하지만, 조인 조건과 일치하지 않더라도 왼쪽 테이블의 결과는 최종 결과에 포함된다.
- 다음은 학생 테이블(왼쪽 테이블)과 지도교수 테이블(오른쪽 테이블)을 왼쪽 외부 조인으로 결합하는 SQL 문이다.
  - 키워드로 LEFT OUTER JOIN 또는 LEFT JOIN을 써서 작성한다.
```sql
  SELECT 학생.학번, 학생.이름, 지도교수.교수명
    FROM 학생
    LEFT OUTER JOIN 지도교수
                 ON 학생.학번 = 지도교수.학번 
```
| 학번  | 이름   | 교수명  |
|-----|------|------|
| 1   | 이순신  | 이황   |
| 2   | 신사임당 | 세종대왕 |
| 3   | 유재석  | NULL |
| 4   | 강감찬  | 김유신  |

#### 오른쪽 외부 조인
- 오른쪽 외부 조인(right outer join)은 오른쪽 테이블(나중에 작성된 테이블) 기준으로 왼쪽 테이블(먼저 작성된 테이블)과 조인을 하지만, 조인 조건과 일치하지 않더라도 오른쪽 테이블의 결과는 최종 결과에 포함된다.
  - 오른쪽 외부 조인은 왼쪽 외부 조인의 방식과 정반대 방식으로 동작하는 조인 연산 방식이다.
```sql
  SELECT 학생.학번, 학생.이름, 지도교수.교수명
    FROM 학생
   RIGHT OUTER JOIN 지도교수
                 ON 학생.학번 = 지도교수.학번 
```
- 이렇게 작성한 SQL 문의 수행결과는 아래과 같다.
  - 학번 99 데이터는 학번 테이블에는 없고 지도교수 테이블에만 있으므로 학생 테이블의 이름 열에는 NULL 값으로 출력된다.
  - 여기서 99번 학생은 퇴학 또는 자퇴 상태로 학생 테이블에서는 이미 데이터가 삭제되었으나, 지도교수 테이블에는 남아 있는 가비지 데이터(garbage data)라고 추측할 수 있다.

| 학번  | 이름   | 교수명  |
|-----|------|------|
| 1   | 이순신  | 이황   |
| 2   | 신사임당 | 세종대왕 |
| 4   | 강감찬  | 김유신  |
| 99  | NULL | 이황   |
- 여기서 오른쪽 외부 조인은 사실 왼쪽 조인에서 조인 순서만 바꾼 것이므로 오른쪽 외부 조인을 왼쪽 외부 조인으로 쉽게 변경할 수 있다.
  - 사람의 인지적 특성상 보통 왼쪽 -> 오른쪽을 정방향으로 인식하므로, 쿼리에서 왼쪽에 위치한 테이블 기준으로 조인을 수행하는 왼쪽 외부 조인을 주로 사용한다.
  - 따라서 오른쪽 외부 조인으로 작성된 SQL 문을 왼쪽 외부 조인으로 변경해서 일관성 있는 SQL 문으로 작성하는 편이 유지보수나 관리 편의성 측면에서 유리하다.

> #### TIP) 전체 외부 조인의 지원 여부
> - 전체 외부 조인은 왼쪽 외부 조인과 오른쪽 외부 조인이 통합된 조인방식으로, MySQL과 MariaDB에서 지원하지 않는다.

#### 교차 조인
- 교차 조인(cross join)은 수학적 관점에서 봤을 때 데카르트 곱(cartesian product)이라고 하는 곱집합 개념으로, 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아내어 반환한다.
  - 모든 경우의 수가 출력 대상으므로 내부 조인에 비해 수십 배에서 수백 배 이상 많은 데이터양을 얻을 수 있다.
  - 다만 조인 연산과정의 시간적 공간적 리소스를 점유 측면에서 오버헤드가 발생하는 만큼 주의해야 한다.
- 다음 코드는 교차 조인을 명시적으로 작성한 SQL 문이다.
  - CROSS JOIN 키워드만으로 두 테이블은 조건 없이 연결하는 조인이 수행된다.
```sql
  SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
    FROM 학생
   CROSS JOIN 지도교수
```
- 다음 코드는 눈에 보이지 않게 암시적으로 교차 조인을 작성한 SQL 문이다.
  - WHERE 절의 조인 조건문이나 JOIN 키워드를 명시하지 않고 작성하면 교차 조인이 수행된다.
```sql
  SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
    FROM 학생, 지도교수
```

#### 자연 조인
- 자연 조인(natural join)은 2개 테이블에 동일한 열명이 있을 때 조인 조건절을 따로 작성하지 않아도 자동으로 조인을 수행해주는 방식이다.
  - 조인이 제데로 성사되면 내부 조인과 동일한 결과가 출력된다.
  - 이때 조인하는 열들의 데이터 유형이 서로 달라도 자연 조인이 수행된다.
- 자연 조인을 의도하고 명시적으로 작성해야 할 키워드는 **NATURAL JOIN** 이다.
  - 해당 키워드를 작성하면 조인 조건절을 알아서 찾아주므로 직접적인 조인 조건문은 작성하지 않는다.
    - 만약 다음 SQL 문에 **ON 학생.학번 = 지도교수.학번** 과 같은 구문을 입력하면 에러가 발생한다.
```sql
  SELECT 학생.*, 지도교수.*
    FROM 학생
 NATURAL JOIN 지도교수 
```    
- 이러한 SQL 문으로 자연 조인을 수행한 결과는 아래와 같다.
  - 학생 테이블과 지도교수 테이블에 동일하게 존재하는 학번 열을 토대로 조인되었음을 확인할 수 있다.
  
| 학번  | 이름   | 성별  | 학번  | 교수명  |
|-----|------|-----|-----|------|
| 1   | 이순신  | 남   | 1   | 이황   |
| 2   | 신사임당 | 여   | 2   | 세종대왕 |
| 4   | 유재석  | 남   | 4   | 김유신  |
- 동일한 열명이 없을 경우에는 발생 가능한 경우의 수를 모두 조합하는 교차 조인으로 수행된다.

### 2.2.5. 조인 알고리즘 용어
- 다수의 테이블에서 조인을 수행할 때는 동시에 여러 개의 테이블에 접근할 수 없는 만큼 접근하는 우선순위를 정하게 된다.
  - 다수의 테이블에서 첫 번째로 접근할 테이블, 두 번째로 접근할 테이블, 세 번째로 접근할 테이블 등 내부적으로 순번을 정하고 차례로 테이블에 접근한 결과를 다음 순번의 테이블로 전달한다.
- 이때 테이블에 접근하는 선후 관계에 따라 드라이빙 테이블과 드리븐 테이블이라는 용어로 구분한다.
  - 한편 각 테이블에 접근해 조인을 수행하는 알고리즘에도 여러 가지 방식이 있다.
  
#### 드라이빙 테이블과 드리븐 테이블
- 드라이빙 테이블(driving table)과 드리븐 테이블(driven table)을 바로 이야기하기 전에 간단한 예제부터 살펴보자.
  - 다음 코드와 같이 학생 정보가 저장된 학생 테이블과 학생 가족 정보가 저장된 비상연락망 테이블이 있다고 가정하자.
  - 이때 학생의 학번이 1과 100에 해당할 때만 학생 정보와 비상연락망 정보를 조회하는 SQL 문이다.
```sql
  SELECT 학생.학번, 학생.이름,
         비상연락망.관계, 비상연락망.연락처
    FROM 학생
    JOIN 비상연락망
      ON 학생.학번 = 비상연락망.학번
   WHERE 학생.학번 IN (1, 100) 
```
  - 이 예제에는 **학생.학번 IN (1, 100)** 조건이 있으므로 학생 테이블의 데이터를 먼저 찾아 볼 것이다.
    - 학생 테이블에서 찾은 결과로 이번에는 비상연락망 테이블에서 학번 1과 100을 검색한다.
    - 이처럼 학생과 비상 연락망이라는 2개 테이블로 분리된 데이터에서 원하는 결과를 추려 결합하는 조인을 수행할 때, 테이블에 동시 접근할 수는 없으므로 테이블의 데이터에 접근하는 우선순위가 존재한다.
    - 이 예제에서 먼저 접근하는 태이블인 드라이빙 테이블(=outer table)은 학생 테이블이고, 그 학생 테이블의 검색 결과를 통해 뒤늦게 데이터를 검색하는 테이블인 드리븐 테이블(=inner table)은 비상연락망 테이블이다.
  - 요약하자면, 학생 테이블이 드라이빙 테이블이고 비상연락망 테이블이 드리븐 테이블이다.
    - 드라이빙 테이블에서 많은 건수가 반호나되면 해당 결과를 가지고 드리븐 테이블에 접근하게 되는 만큼 사실상 드라이빙 테이블을 무엇으로 선정할지는 매우 중요한 문제이다.
    - 가능하면 적은 결과가 반환될 것으로 예상되는 드라이빙 테이블을 선정하고, 조인 조건절의 열이 인덱스로 설정되도록 구성해야 한다.
- 지금까지 설명한 드라이빙 테이블과 드리븐 테이블의 개념을 토대로, 성능 향상에 필요한 조인 알고리즘의 개념과 간단한 튜닝 방법을 알아보자.

#### 중첩 루프 조인
- 중첩 루프 조인(nested loop join)(NL 조인)은 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로 양쪽 테이블에 공통된 데이터를 출력한다.
  - 중첩 루프 조인의 특성을 알아보고자 몇 가지 조건을 기준으로 중첩 루프 조인을 수행할 예정이다.
- 먼저 기본 키와 인덱스가 없는 두 테이블이 존재하는 상황에서 다음과 같은 SQL 문으로 극단적인 중첩 루프 조인을 수행한다.
```sql
  SELECT 학생.학번, 학생.이름,
         비상연락망.관계, 비상연락망.연락처
    FROM 학생
    JOIN 비상연락망
      ON 학생.학번 = 비상연락망.학번
   WHERE 학생.학번 IN (1, 100) 
```
  - 학번 1과 100에 해당하는 학생들의 학생 정보와 비상연락망 정보를 가져오고자 한다.
    - 먼저 학번 1을 학생 테이블에서 검색하려고 학생 테이블의 데이터 100건에 모두 접근한다.
    - 이후 학번 1과 동일한 데이털르 가졌는지 비교해보려고 비상연락망 테이블의 데이터 1,000건에 모두 접근한다.
  - 다음으로 학번 100의 학생 정보를 찾고자 학생 테이블의 데이터 100건에 모두 접근한다.
    - 이후 마찬가지로 학생 테이블의 학번 100 데이터와 동일한 데이터를 가졌는지 비교해보려고 비상연락망 테이블에서 학번 100을 찾는 작업을 반복한다.
    - 이처럼 학번 1 데이터(100 + 1,000)와 학번 100 데이터(100 + 1,000)을 조회하기 위해 대략 2,200건의 데이터에 접근하는 것이다.
  - 데이터가 정렬되어 있다고 가정하자.
    - 보통 테이블 데이터가 뒤엉켜 있을 가능성이 높다는 걸 명심하자.
    - 해당 경우에는 학생 테입르에 학번 열로 인덱스가 생성되어 있고, 비상연락망 테이블에도 학번 열로 인덱스가 생성되어 있는 환경을 가정하자.
    - 앞에서 수행한 SQL 문을 똑같이 수행하면 각 테이블에 생성된 인덱스로 데이터에 접근한다.
    - 이를 정량적 수치로 표현하면 학번 1인 데이터(1+2)와 학번 100인ㅇ 데이터(1+1)를 찾기 위해 총 6건의 데이터에 접근하게 된다.,
    - 단, 인덱스의 다음 값을 확인하고 접근 대상이 되는지 여부를 판단하는 것도 실제로는 접근 횟수에 포함되어야 하지만 여기서는 메커니즘의 이해를 돕고자 단순히 학번 1과 100에 해당하는 데이터만 계산했다.
      - 사실, 인덱스는 인덱스로 정의되나 열 기준으로 순차 정렬되지만, 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 랜덤 액세스(random access)가 발생한다.
      - 따라서 랜덤 액세스를 줄일 수 있도록 데이터의 엑세스 범위를 좁히는 방향으로 인덱스를 설계하고 조건절을 작성해야 한다.
      - 단, 랜덤 액세스를 유발하는 인덱스는 기본 키가 아닌 비고유 인덱스일 경우에 해당한다.
      - 기본 키는 클러스터형 인덱스이므로 기본 키의 순서대로 테이블의 데이터가 적재되어 있어 조회 효율이 매우 높다.
      
#### 블록 중첩 루프 조안
- 블록 중첩 루프 조인(block nested loop join)(BNL 조인)을 설명하기 전에 탄생 배경부터 알아보자.
  - 학생 테이블이 드라이빙 테이블이고 비상연락망 테이블은 인덱스 없이 생성되어 있따고 가정하자.
  - 이때 중첩 루프 조인을 수행한다면 학생 인덱스로 학번 1 데이터를 찾은 뒤, 인덱스가 없는 비상 연락망 테이블의 전체 데이터에 모두 접근해야 할 것이다.
  - 이후 학생 테이블에서 학번 100 데이터를 찾고, 또다시 비상연락망 테이블은 전체 데이터 1,000건에 접근한다.
  - 즉, 인덱스가 없는 드리븐 테이블에 대해 매번 전체 테이블를 비효율적으로 검색해야 한다.
- 이때 중첩 루프 조인의 효율성을 높이고자 탄생한 것이 바로 블록 중첩 루프 조인이다.
  - 드라이빙 테이블에 대해 조인 버퍼(join buffer)라는 개념을 도입하여 조인 성능의 향상을 꾀할 수 있다.
  - BNL 조인이 수행되는 절차는 다음과 같다.
    - (1) 드라이빙 테이블인 학생 테이블에서 학번 1과 100에 해당하는 데이터를 검색한다.
    - 검색한 데이터를 (0) 조인 버퍼에 가득 채워질 때까지 적재한다.
    - 이후 (0) 조인 버퍼와 비상연락망 테이블의 데이터를 비교한다.
    - 즉 (0) 조인 버퍼와 (2) 데이터를 조인하고, 다시 (0) 조인 버퍼와 (3) 데이터를 조인하는 식으로 반복하여 비상연락망 데이터에 모두 접근한다.
    - 이처럼 조인 버퍼의 데이터들과 비상연락망의 테이블의 한 번의 테이플 풀 스캔(table full scan)으로 원하는 데이터를 모두 찾을 수 있다.
    - 이 과정은 비상연락망 테이블의 테이블 풀 스캔을 줄이는 게 목적으로, 성능 저하를 개선하는 알고리즘 방식이다.
  - 추가로 블록 해시 조인(block hash join)이라는 방식도 있지만, 블록 중첩 루프 조인 방식과 매우 유사하므로 설명은 생략하겠다.
    - 이 방식은 조인 버퍼에 쌓인 데이터에 대해 해시값을 적용하고 그 값을 기준으로 비상연락망 테이블과 조인을 수행한다는 점이 다르다.
    
#### 배치 키 액세스 조인
- 중첩 루프 조인 방식은 필연적으로 데이터 접근 시 인덱스에 의한 랜덤 엑세스가 발생하므로, 액세스할 데이터의 범위가 넓다면 분명 비효율적인 조인 방식이다.
  - 이러한 랜덤 액세스의 단점을 해결하고자 접근할 데이털르 미리 예상하고 가져오는 데 착안한 조인 알고리즘을 배치 키 액세스 조인(batched key acces join)(BKA 조인)이라 한다.
- BKA 조인은 블록 중첩 루프 조인에서 활용한 드라이빙 테이블의 조인 버퍼 개념을 그대로 사용한다.
  - 그리고 드리븐 테이블에 필요한 데이터를 미리 예측하고 정렬된 상태로 담는 랜덤 버퍼의 개념을 도입한다.
  - 이때 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능을 다중 범위 읽기(MRR: multi range read)라고 한다.
  - 즉, 미리 예측된 데이터를 가져와 정렬된 상태에서 랜덤 버퍼에 담기 때문에, 드리븐 테이블에 대해 랜덤 액세스가 아닌 시퀀셜 액세스를 수행하는 방식인 것이다.
  

#### 해시 조인
- 해시 조인(hash join)은 MySQL 8.0.18 버전부터 지원되는 조인 방식이다.
  - 기존의 중첩 루프 조인 방식에서 조금 개선된 버전인 블록 중첩 루프 조인과 배치 키 액세스 조인의 한계를 탈피하는 시발점이다.
- 해시 조인은 선후 관계를 두고 조인을 수행하는 중첩 루프 조인 방식과 달리, 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행한다.
  - 해시값으로 내부 조인을 수행한 결과는 조인 버퍼에 저장되므로 조인 열의 인덱스를 필수로 요구하지 않아도 된다.
---