# 2장. SQL 튜닝 용어를 직관적으로 이해하기
- SQL 튜닝에 앞서 기본적으로 알아야 할 용어를 짚고 넘어가자.
- 튜닝을 수행하는 과정에서 DBMS의 전반적인 구조와 메커니즘에 기반을 둔 종합적 사고를 필요한 만큼 현업에서 통용되는 기본적인 용어는 반드시 알고 있어야 한다.

## 2.1. 물리 엔진과 오브젝트 용어
### 2.1.1. DB 엔진 용어
- MySQL이라는 DBMS는 데이털르 저장하고, 저장된 데이터를 가공하는 연산을 수행한다.
- 푸트코트에서 음식을 주문한다 가정하자.
  - 점원은 주문한 메뉴가 조리 가능한 음식인지, 재료가 떨어진 음식은 아닌지, 메뉴판에 기재된 음식인지와 같은 세부 항목을 확인한다.
  - 이후 손님이 주문한 메뉴는 한식 조리실로 전달되어 조리되며 완성된 음식은 점원에게 전달된다.
  - 메뉴 주문을 받고 서빙하는 점원은 완성된 음식을 접시에 예쁘게 담고, 꽃과 악세사리로 플레이팅하여 손님에게 제공된다.
- 이처럼 손님의 요구사항은 조리실까지 차례로 전달되며, 조리실에서는 해당 메뉴를 저장된 재료로 요리한다.
  - 완성된 음식은 접시에 담아 꾸미고 더러워진 부분은 깨끗이 닦아 손님에게 제공한다.
  - 이러한 일련의 과정은 SQL 문 요청에 따라 최종 결과가 출력되기까지의 과정과 크게 다르지 않다.
- 푸트코트에서 음식을 주문하는 과정과 마찬가지로, 사용자는 DB에서 원하는 데이터를 가져오고자 SQL 문을 실행한다.
  - 실행된 SQL 문은 MySQL 엔진에서 문법 에러가 있는지, DB에 존재하는 테이블 대상으로 SQL 문을 작성했는지와 같은 세부 사항을 다양한 문법 및 구문으로 검사한다.(파싱 작업을 하는 파서(parser) 역할)
  - 이후 사용자가 요청한 데이터를 빠르고 효율적으로 찾아가는 전략적 계획을 수립한다.(옵티마이저(optimizer) 역할)
  - 이 계획을 토대로 스토리지 엔진에 위치한 데이터까지 찾아간 뒤 해당 데이터를 MySQL 엔진으로 전달한다.
  - MySQL 엔진은 전달된 데이터에서 불필요한 부분을 필터링(제거, 변경)하고 필요한 연산을 수행한 뒤 사용자에게 최종 결과를 알려준다.

#### 스토리지 엔진
- (InnoDB, MyISAM, Memory 등) 스토리지 엔진은 사용자가 요청한 SQL 문을 토대로 DB에 저장된 디스크나 메모리에서 필요한 데이털르 가져오는 역할을 수행한다.
  - 이후 해당 데이터를 MySQL 엔진으로 보내준다.
  - 스토리지 엔진이 데이터를 저장하는 방식에 따라 각각의 스토리지 엔진을 선택하여 사용할 수 있으며, 필요하다면 외부에서 스토리지 엔진 설치 파일을 가져와 활성화하여 즉시 사용할 수 있다.
- 일반적으로 온라인상의 트랜잭션 발생으로 데이터를 처리하는 OLTP(online transaction processing) 환경이 대다수인 만큼 주로 InnoDB 엔진을 사용한다.
  - 그 밖에도 대량의 쓰기 트랜잭션이 발생하면 MyISAM 엔진을, 메모리 데이터를 로드하여 빠르게 읽는 효과를 내려면 Memory 엔진을 사용하는 식으로 응용하여 스토리지 엔진을 선택할 수 있다.

#### MySQL 엔진
- MySQL 엔진은 사용자가 요청한 SQL 문을 넘겨받은 뒤 SQL 문법 검사와 적절한 오브젝트 활용 검사를 하고, SQL 문을 최소 단위로 분리하여 원하는 데이터를 빠르게 찾는 경로를 모색하는 역할을 수행한다.
  - 이후 스토리지 엔진으로부터 전달받는 데이터 대상으로 불필요한 데이터는 제거하거나 가공 및 연산하는 역할을 한다.
  - 즉, SQL 문의 시작 및 마무리 단계에 MySQL 엔진이 관여하며, 스토리지 엔진으로부터 필요한 데이터만을 가져오는 핵심 역할을 담당한다고 할 수 있다.

### 2.1.1. SQL 프로세스 용어
- SQL 문은 의외로 복잡한 과정을 거쳐 결괏괎을 출력한다.,
- 그 복잡한 과정을 택기 기사에 비유해보자.
  - 서울에서 택시 운전을 하는 A씨는 첫 번째 손님을 태웠다.
  - 탑승한 손님은 몽골어로 "dfgjjkbdgd d gsgdgds"라고 요구했으나 무슨 뜻인지 알 수 없어 목적지까지 안내할 수 없었다.
  - 다음으로 두 번째 손님은 "뉴욕으로 가주세요."라고 요구했고, A 씨는 어떤 요구사항인지 이해해보려 했으나 한국에는 뉴욕이라는 도시가 없으므로 결국 두 번째 손님도 목적지로 안내할 수 없었다.
  - 마지막으로 태운 손님은 "부산으로 가주세요."라고 말했고 택시 기사 A 씨는 손님이 원하는 내용을 충분히 이해했고 부산의 위치도 정확히 알고 있었다.
- SQL 문을 수행하는 과정 역시 택시 기사 A 씨가 일상에서 겪은 경험과 크게 다르지 않았다.
  - 사용자가 SQL 문을 수행하면, 파서는 MySQL이 이해할 수 있는 최소 단위로 구성요소를 분리하고 해당 구성 요소를 트리로 만든다.
  - 트리를 만드는 과정에서는 문법 오류가 있는지 검토한다.
  - 트리의 최소 단위는 >, <, = 등의 기호나 SQL 키워드로 분리한다.
  - 만약 트리에 허용되지 않는 문법이 포함된다면 에러 발생과 동시에 실행이 종료된다.
- 이후 전처리기(preprocessor)는 생성된 트리 결과를 토대로, 이미 만들어진 테이블이나 뷰 등으로 구성되지는 않는지, 존재하지 않은 열을 포함하지는 않는지, 조회 권한이 없는 테이블을 조회하는지 등 유효성을 검증한다.
  - 만약 유효하지 않은 오브젝트가 있거나 권한이 없는 오브젝트를 호출하면 바로 에러를 발생하여 사용자에게 표시한다.
- 다음으로 옵티마이저(optimizer)는 트리를 구성하는 오브젝트의 데이터를 효율적으로 가져오기 위해 시간은 적게 소요되면서도 비용 효율적인 경로로 데이터를 검색하는 방법에 관한 실행 계획을 수립한다.
  - 엔진 실행기(engine executor)는 이전에 수립된 실행 계획으로 스토리지 엔진을 호출해 필요한 데이터를 가져온다.
  - 이휴 엔진 실행기는 스토리지 엔진을 통해서 가져온 데이터 중 불필요한 데이터를 필터링하여 사용자가 원하는 결과를 전달한다.
- 이렇게 SQL 실행 과정에서 핵심 역할을 수행하는 오브젝트는 크게 파서, 전처리기, 옵티마이저, 엔진 실행기로 구분된다.

#### 파서
- 파서(parser)는 MySQL 엔진에 포함되는 오브젝트로, 사용자가 요청한 SQL 문을 쪼개 최소 단위로 분리하고 트리를 만든다.
  - 트리를 만들면서 문법 검사를 수행한다.

#### 전처리기
- 전처리기(preprocessor)는 MySQL 엔진에 해당하는 오브젝트로, 파서에서 생선한 트리를 토대로 SQL 문에 구조적인 문제가 없는지 파악한다.
  - SQL 문에 작성된 테이블, 열, 함수, 뷰와 같은 오브젝트가 실질적으로 이미 생성된 오브젝트인지, 접근 권한은 부여되어 있는지 확인하는 역할은 한다.
  
#### 옵티마이저
- 옵티마이저(optimizer)는 MySQL 의 핵심 엔진 중 하나로, DBMS에서 두뇌라고 불러도 과언이 아닐 만큼 핵심적인 역할을 수행한다.
  - 전달된 파서 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정에서 단순화한다.
  - 나아가 어떤 순서로 테이블에 접근할지, 인덱스를 사용할지, 사용한다면 어떤 인덱스를 사용할지, 정렬할 때 인덱스를 사용할지 아니면 임시 테이블(temporary table)을 사용할지와 같은 실행 계획을 수립한다.
- 단, 실행 계획으로 도출할 수 있는 경우의 수가 지나치게 많을 때는 실행 계획을 수립하고 비용을 산정하여 최적은 실행 계획을 선택하기까지 시간이 오래 걸리는 만큼 모든 실행 계획을 판단하지는 않는다.
  - 이는 옵티마이저가 선택한 최적의 실행 계획이 최상의 실행 계획은 아닐 가능성도 있다는 걸 의미한다.
- 실행 계획을 수립하는 작업 자체만으로도 사용자의 대기 시간과 하드웨어 리소스를 점유하므로, 시간과 리소스에 제한을 두고 실행 계획을 선정해야 한다.
  - 이처럼 옵티마이저가 예측한 모든 실행 계획이 항상 최적의 실행 계획은 아닌 만큼 MySQL과 MariaDB를 적절히 다루는 우리들의 손길이 필요할 수 있다.

#### 엔진 실행기
- 엔진 실행기(engine executor)는 MySQL 엔진과 스토리지 엔진 영역 모두에 걸치는 오브젝트로, 옵티마이저에서 수립한 실행 계획을 참고하여 스토리지 엔진에서 데리터를 가져온다.
  - 이후 MySQL 엔진에서는 읽어온 데이터를 정렬하거나 조인하고, 불필요한 데이터는 필터링 처리하는 추가 작업을 한다.
  - 따라서 MySQL 엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터양을 줄이는 게 매우 중요하다.

### 2.1.3. DB 오브젝트 용어
- 데이터베이스를 구성하는 요소 중 하나로 오브젝트(object)라 불리는 객체들이 있다.
  - 이에 쿼리 튜닝을 수행하기 전에 각 오브젝트의 개념을 간단히 살펴보자.
- 2차원 형태의 관계형 데이터베이스에서 표는 테이블(table), 열은 컬럼(column), 행은 로우(row)라는 용어로 사용한다.

#### 테이블
- 테이블(table)은 데이터를 저장하는 오브젝트로 행과 열의 정보를 담는다.
  - 관계형 데이터베이스인 MySQL은 2차원 배열 형태로 테이블을 관리한다.
  - 테이블에서는 저장 방식과 저장 구조에 따라 스토리지 엔진 속성을 정의할 수 있다.
  - InnoDB 스토리지 엔진은 보통 OLTP 환경에서 주로 사용하는 기본 DB 엔진이며 그 외에도 MyISAM, Memory, Blackhole 엔진 등이 있다.

#### 로우(행)
- 로우(row)는 행에 해당하는 용어로, 테이블에서 동일한 구조의 데이터 항목들의 집합을 가리킨다.
  - 학생 테이블을 예로 10001/홍길동/20001021/010-123-4567/CS 라는 5개의 데이터 항목이 하나의 행을 이룬다.
  - 다른 행 역시 데이터의 값 자체는 다르지만 데이터 항목의 구조는 동일하다.
  - 즉, 행은 하나의 데이터 항목 집합이며 모든 행의 집합을 테이블이라고 할 수 있다.
- 행 수가 많아지면 데이터에 접근하는 과정에서 시간이 오래 소요될 가능성이 높다.
  - 이때 파티셔닝(partitioning) 기법으로 SQL 문의 성능 향상을 검토해볼 수 있다.

#### 컬럼(열)
- 컬럼(column)은 열에 해당하는 용어이다.
  - 사전에 정의한 데이터 유형으로 데이터값을 저장하며, 일별로 다른 데이터 유형을 가질 수 있다.

#### 기본 키
- 기본 키(PK: primay key)는 특정 행을 대표하는 열을 가리키는 용어로 주 키라고도 한다.
  - 기본 키는 1개 열만으로 생성하지만 상황에 따라 2개 이상의 열을 조합해 기본 키를 구성할 수도 있다.
  - 또한 기본 키는 향후 설명한 인덱스(index) 역할도 수행하므로 기본 키를 활요하여 인덱싱할 수 있음을 알고 있어야 한다.
- MySQL/MariaDB에서 기본 키는 클러스터형 인덱스(clustered index)로 작동한다.
  - 이는 기본 키의 구성 열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓인다는 뜻이다.
  - 즉, 비슷한 기본 키 값들이 근거리에 적재되므로 기본 키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근할 수 있다.

> #### 인덱스의 주의사항
> - 기본 키와 똑같은 인덱스를 생성하면 인덱스가 저장되는 물리적 공간이 낭비되는 한편 데이터의 삽입/삭제/수정에 따른 인덱스 정렬의 오버헤드가 발생한다.
> - 다음 예제는 학생 테이블을 생성하는 DDL(Data Definition Language) 문으로, 기본 키와 I_학번 인덱스를 똑같은 학번 열로 생성한다.
>   - 이처럼 기본 키와 같은 열로 만들어진 I_학번 인덱스는 불필요한 공간 낭비와 정렬의 오버헤드가 발생하므로 삭제해야 한다.
> ```sql
> CREATE TABLE 학생 (
>   학번      INT(11)  NOT NULL,
>   이름      VARCHAR  NOT NULL,
>   생년월일   DATE     NOT NULL,
>   연락처    VARCHAR(16) NOT NULL,
>   전공코드   VARCHAR(3) NOT NULL,
>   PRIMARY KEY (학번),
>   INDEX I_학번 (학번)
> )
> ```

#### 외래키
- 외래 키(FK: foreign key)는 외부에 있는 테이블을 항상 참조하면서, 외부 테이블의 데이터가 변경되면 함께 영향을 받는 관계를 설정하는 키이다.
  - 여기서 외부 테이블을 부모 테이블, 외부 테이블을 참조하는 테이블을 자식 테이블이라고 생각하면 이해하기 쉽다.
- 학생 테이블에서는 전공코드값에 변경사항이 발생할 때마다 외래키 설정조건을 항상 검증하므로 데이터 정합성 향상을 위해서라도 외래 키를 설정한다.

#### 학생 테이블
| 학번(PK) | 이름   | 전공코드(FK)  |
|--------|------|-----------|
| 10001  | 홍길동  |CS|

#### 전공 테이블
| 전공코드(FK) | 전공명     | 
|----------|---------|
| CS       | 컴퓨터공학   |

#### 인덱스
- 인덱스(index)는 데이터베이스에서 키값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트이다.
- 예를 들어 천만 건의 데이터로 구성된 책이 있는데 그 안에서 특정 정보를 검색해야 한다면 어떤 방법으로 원하는 정보를 가장 빨리 찾을 수 있을까?
  - 첫 번째 행부터 마지막 행까지 하나씩 살펴보는 게 가장 정확하고 빠른 방법이다.
    - 그러나 책의 두께가 두꺼워질수록 검색할 분량이 기하급수적으로 늘어나면서 검색 속도가 급격히 느려지므로 매우 비효율적인 방법이다.
  - 이처럼 책의 처음부터 끝까지 전부 차례로 검색하는 비효율적인 방식을 개선하고자 인덱스를 만든다.
    - 편의상 영문으로 구성된 책이라고 가정하면 다음과 같은 형태가 된다.
      - ```text
        INDEX
        A
        ant       ... page 999
        apple     ... page 3
      
        B
        banana    ... page 762  
      
        C
        circle    ... page 1004
        clock     ... page 421
        cpu       ... page 83
        ``` 
    - 예를 들어 ant라는 단어는 999페이지에 있으며 apple은 3페이지, banana는 762페이지에 있다는 식으로 구성된다.
    - 이처럼 정렬된 각 키워드가 어느 곳에 있는지를 인데긋라는 이름으로 구성하면, 키워드 검색으로 원하는 페이지를 빠르게 찾을 수 있다.
- MySQL의 특성상 기본 키(PK) 기준으로 데이터가 쌓인다.
- 인덱스는 생성하려는 열의 속성에 따라 고유 인덱스(unique index)와 비고유 인덱스(non-unique index)로 구분할 수 있다.
  - 참고로, 흔흐 거론되는 인덱스는 비고유 인덱스이다.

> #### 고유 인덱스
> - 고유 인덱스(unique index)란 말 그대로 인덱스를 구성하는 열들의 데이터가 유일하다는 의미이다.
>   - 차례로 정렬되는 인덱스 열의 데이터는 서로 중복되지 않고 유일성을 유지한다.
>   - 만약 동일한 데이터가 생성되면 고유 인덱스의 중복 체크 과정에서 에러가 발생한다.
>   - 또한 중복이 없는 열들을 고유 인덱스로 생성하려 한다면 중복이 있는지 검증하는 절차를 거쳐야 하므로, 불필요한 중복 검증 과정이 추가되니 주의해야 한다.

> #### 기본 키와 고유 인덱스의 차이점
> - 기본 키와 고유 인덱스의 특성이 유사해 혼란스러울 때가 많다.
>   - 이러한 혼란은 기본 키와 고유 인덱스 모두 데이터의 유일성을 보장해야 하는 특성과 효율적인 데이터 접근을 위한 인덱스로의 수단으로 사용되기 때문이다.
>   - 다만 기본 키에는 NULL을 입력할 수 없지만 고유 인덱스에는 얼마든지 입력할 수 있다는 게 차이점이다.
 
> #### 비고유 인덱스
> - 비고유 인덱스(non-unique index)는 고유 인덱스에서 데이터의 유일한 속성만 제외한 키이다.
>   - 데이터가 신규 입력되어 인덱스가 재정렬되더라도 인덱스 열의 중복 체크를 거치지 않고 단순한 정렬 작업을 수행한다.
> - 중복이 자주 발생할때 비고유 인덱스를 생성한다.

#### 뷰
- 뷰(view)는 일명 가상 테이블이라고 이해하면 된다.
  - 물리적으로 잡히지 않는 유령과 같은 오브젝트이다.
- 올림픽 경기장에서 열리는 콘서트에 참석하지 못하는 대신 실시간 스트리밍으로 해당 콘서트를 관람하는 상황을 가정해보자.
  - 이떄 실제 올림픽 경기장에서 열리는 콘서트장을 '테이블'이라고 한다면, 실체는 없지만 간접적으로 대상을 확인할 수 있는 스트리밍 방식을 '뷰'라고 할 수 있다.
- 원래 테이블의 데이터가 변경되면 뷰 테이블에서 또한 바로 변경된 데이터를 조회할 수 있다.
  - 반대로 뷰 테이블에서 데이터를 변경하면 원래 테이블의 해당 데이터도 즉시 변경된다.
- 나아가 개인정보와 같이 외부에 직접적으로 공개하지 않고 뷰 테이블을 만들어 제한된 정보만을 제공할 수 있다.
  - 시스템을 안전하게 운영하고 개발할 수 있는 환경을 제공하는 만큼 보안성 측면에서 뷰의 가치가 부각된다.

> #### 뷰를 사용하는 이유
> - 뷰를 사용하는 이유는 일부 데이터에 대해서만 데이터를 공개하고, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성 때문이다.
>   - 한편 여러 개의 테이블을 병합(join)해서 활용할 때는 성능을 고려한 최적화된 뷰를 생성함으로써 일관된 성능을 제공할 수 있다.

---