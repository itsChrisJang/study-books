#  01. 객체, 설계

## 01. 티켓 판매 애플리케이션 구현하기
- 소극장을 경영하고 있다 상상하자.
- 소극장 홍보도 할 겸 작은 이벤트를 기획했다.
  - 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송하는것이다.
- 이벤트에 당첨된 관람객과 그렇지 못한 관람객은 다른 방식으로 입장시켜야 한다.
  - 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후 입장할 수 있다.
  - 그렇지 않은 관람객은 티켓을 구매해야만 입장할 수 있다.
- 따라서 관람객 입장전 이벤트 당첨 여부를 확인하고 이벤트 당첨자가 아닌 경우 티켓을 판매한 후에 입장시켜야 한다.

## 02. 무엇이 문제인가
- 로버트 마틴의 소프트웨어 모듈이 가져야 하는 세 가지 목적
  1. 실행 중에 제데로 동작하는 것
     - 이것은 모듈의 존재 이유.
  2. 변경을 위해 존재하는 것
     - 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.
     - 변경하기 어려운 모듈은 제데로 동작하더라도 개선해야 한다.
  3. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 함.
     - 읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.
### 예상을 빗나가는 코드
- 이해 가능한 코드
  - 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드
- 이해 어려운 코드
  - 여러가지 세부적인 내용들을 한꺼번에 기억하고 있어야 하는 코드 

### 변경에 취약한 코드
- 의존성(Dependency)
  - 어떤 객체가 변경될 떄 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실
- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다.
- 따라서 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다.
- 객체 사이의 의존성이 과한 경우를 가리켜 **결합도(Coupling)** 가 높다고 한다.
  - 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다.
  - 따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이다.

## 03. 설계 개선하기
### 자율성을 높이자
- **캡슐화(encapsulation)**
  - 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것이다.
  - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.
  - 목적
    - 변경하기 쉬운 객체를 만드는 것
- 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

### 어떻게 한 것인가
- 자기 자신의 문제를 객체 스스로가 해결하도록 코드를 변경하도록 했다.

### 캡슐화와 응집도
- 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 개체를 가리켜 **응집도(Cohesion)** 가 높다라고 한다.
- 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을 뿐만 아니라 응집도를 높일 수 있다.
- 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다.
  - 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재가 되어야 한다. (응집도를 높이는 첫 걸음)
- 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다.

### 절차지향과 객체지향
- **절차지향 프로그래밍(Procedural Programming)**
  - **프로세스(Process)** 와 **데이터(Data)** 를 별도의 모듈에 위치시키는 방식
  - 변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계
  - 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.
- **객체지향 프로그래밍(Object-Oriented Programming)**
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식
  - OOP의 핵심은 **캡슐화** 를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.
- **책임의 이동(Shift of Responsibility)**
  - '책임'을 기능을 가리키는 객체지향 세계의 용어로 본다.
  - 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 **자신을 스스로 책임** 진다.
  - 객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체를 구성함으로써 완성된다.
  - 이런 관점에서 객체지향 프로그래밍을 흔히 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식으로 표현하기도 한다.
  - 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다.
- **의존성**
  - 설계를 어렵게 만드는 것
  - 해결 방법
    - 불필요한 의존성을 제거함으로써 객체 사이의 **결합도** 를 낮추는 것이다. (= 캡술화)
    - 결과적으로 불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 **자율성** 을 높이고 **응집도** 높은 객체들의 공동체를 창조할 수 있게 된다.

### 그래, 거짓말이다.
- 객체지향의 세계에서는 모든 것이 능동적이고 자율적인 존재로 바뀐다.
- 레베카 워프스브록은 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 **의인화(anthropomorphism)** 라고 부른다.
- 훌류안 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다.
- 그 대상이 비록 실세계에서는 생명이 없는 수동적인 존재라고 하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명가 지능을 가진 싱싱한 존재로 다시 태어난다.

## 04. 객체지향 설계
### 설계가 왜 필요한가?
- 설게란 코드를 배치하는 것이다.
- 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다.
- 좋은 설계란?
  - 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야 한다.
  - 좋은 설계란 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.

### 객체지향 설계
- 변경에 유현하게 대응할 수 있는 코드가 우리가 진정으로 원하는 것이다.
- 변경 가능한 코드란 이해하기 쉬운 코드이다.
- 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계이다.
- 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 객체지향 설계로 가는 첫걸음일 뿐이다.
  - 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다.

---
