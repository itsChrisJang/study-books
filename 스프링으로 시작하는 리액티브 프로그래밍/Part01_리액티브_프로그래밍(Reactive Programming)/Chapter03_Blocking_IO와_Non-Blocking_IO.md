# 스프링으로 시작하는 리액티브 프로그래밍
## Chapter03. Blocking I/O와 Non-Blocking I/O
> - Chapter 2에서는 '리액티브 스트림즈는 데이터 스트림을 Non-Blocking 이면서 비동기적인 방식으로 처리하기 위한 리액티브 라이브러리의 표준 사양이다'라고 설명했다.
> - Non-Blocking 이 무엇을 뜻하는지 이해해보자.
### 3.1. Blocking I/O
- 운영체제를 학습할 때 빠지지 않는 내용 중의 하나가 바로 I/O 이다.
  - 운영체제 측면에서의 I/O 는 일반적으로 컴퓨터 시스템이 외부의 입출력 장치들과 데이터를 주고 받는 것을 의미하며, I/O 작업의 대표적인 예로 디스크에 저장된 프로그램 실행파일을 읽어 들여 메모리에 올리는 것을 들 수 있다.
- 그렇다면 웹 애플리케이션 측면에서 I/O 작업에는 어떤 것이 있을까?
  - 우선 가장 먼저 파일에서 데이터를 읽어 들이거나 파일에 데이터를 기록하는 작접을 떠올릴 수 있다.
- 그리고 웹 애플리케이션에서 다른 웹 애플리케이션으로 네트워크 통신을 한다면 **네트워크 I/O** 가 발생하는 것이다.
  - Apache Tomcat 같은 서블릿 컨테이너 등에서 실행되는 웹 애플리케이션은 동적인 데이터를 처리해야 되기 때문에 어떤 식으로든 I/O 가 발생하게 된다.
- 하나의 스레드가 I/O에 의해서 차단되어 대기하는 것은 **Blocking I/O** 라고 한다.
- Blocking I/O 방식의 문제점을 보완하기 위해서 멀티스레딩 기법으로 추가 스레드를 할당하여 차단된 그 시간을 효율적으로 사용할 수는 있다.
- 그렇지만 이렇게 CPU 대비 많은 수의 스레드를 할당하는 멀티스레딩 기법은 몇가지 문제점이 존재한다.
  1. **컨텍스트 스위칭(Switching)으로 인한 스레드 전환 비용이 발생한다.**
    - 예를 들어 우리가 컴퓨터 상에서 뮤직 플레이어로 음악을 들으면서 동시에 웹 서핑을 하고 있다면 우리 눈에는 두 프로그램이 동시에 실행되는 것처럼 보이지만 실제로 컴퓨터 상에서는 두 개의 프로그램을 번갈아 가면서 실행시켜 주는 것이다.
    - 번갈아 가면서 실행시키는 그 속도가 너무 빠르기 때문에 우리 눈에는 두 개의 프로그램이 동시에 실행되는 것처럼 보이는 것이다.
    - 이렇게 두 개의 프로그램이 번갈아 가며 실행되는 과정에서 기존에 실행되고 있는 프로세스의 정보를 **PCB(Process Control Block)** 라는 공간에 저장하고, 다시 실행시켜야 할 프로세스 정보를 PCB 로부터 불러오는 그 과정을 바로 **컨텍스트 스위칭(Context Switching)** 이라고 한다.
    - 왜 컨텍스트 스위칭이 문제가 되는 것일까?
      - 바로 프로세스의 정보를 PCB 에 저장하고 PCB 에서 프로세스 정보를 reload 하는 데 일정 시간이 소요되기 때문이다.
      - 이렇게 **프로세스의 정보를 PCB 에 저장, reload 하는 시간 동안에는 CPU 가 다른 작업을 하지 못하고 대기** 하게 된다.
      - 당연히 **컨텍스트 스위칭이 많으면 많을수록 CPU 의 전체 대기 시간은 길어지기 때문에 성능이 저하** 되는 것이다.
  2. **과다한 메모리 사용으로 오버헤드가 발생할 수 있다.**
    - 일반적으로 새로운 스레드가 실행되면 JVM 에서는 해당 스레드를 위한 스택(Stack) 영역의 일부를 할당하며, 새로운 스레드의 정보는 스택 영역에 개별 프레임(Stack Frame)의 형태로 저장된다.
    - JVM 의 디폴트 스택 사이즈는 64비트의 경우 1024KB 이다.
      - 만약에 64,000명이 동시 접속을 한다면, 총 64GB 정도의 메모리가 추가로 필요하게 된다.
    - 일반적으로 서블릿 컨테이너 기반의 Java 웹 애플리케이션은 **요청당 하나의 스레드(thread per request)**를 할당한다.
      - 만약 각각의 스레드 내부에서 또 다른 작업을 처리하기 위해 스레드를 추가로 할당하게 된다면, 시스템이 감당하기 힘들 정도로 메모리 사용량이 늘어날 가능성이 있다.
  3. **스레드 풀(Thread Pool)에서 응답 지연이 발생할 수 있다.**
    - Spring Boot 은 자체적으로 톰캣(Tomcat)이라는 서블릿 컨테이너를 내장한다.
      - 그리고 톰캣은 사용자의 요청을 효과적으로 처리하기 위해 스레드 풀을 사용한다.
      - 스래드 풀이란 일정 개수의 스레드를 미리 생성하고 풀에 저장해 두고 사용자의 요청이 들어올 경우, 아직 사용되지 않고 있는 스레드가 있다면 풀에서 꺼내어 사용할 수 있도록 하는 일종의 스레드 저장소이다.
    - 스레드 폴을 사용하지 않는다면 요청이 들어올 때마다 스레드를 처음부터 새로 생성해야 하기 때문에 스레드 생성과 수거에 비용이 많이 든다.
      - 하지만 스레드 풀을 사용한다고 하더라도 또 다른 문제가 발생할 수 있다.
    - 대량의 요청이 발생하게 되어 스레드 풀에 사용 가능한 유휴 스레드가 없을 경우, 사용 가능한 스레드가 확보되기 전까지 응답 지연이 발생한다.
      - 이러한 응답 지연에는 반납된 스레드가 사용 가능하도록 전환되는 지연 시간이 포함된다.
### 3.2. Non-Blocking I/O
- **작업 스레드의 종료 여부와 관계없이 요청한 스레드는 차단되지 않는다.**
  - 스레드가 차단되지 않기 때문에 하나의 스레드로 많은 수의 요청을 처리할 수 있다.
- 즉, Blocking I/O 방식보다 더 적은 수의 스레드를 사용하기 때문에 Blocking I/O 에서 멀티스레딩 기법을 사용할 때 발생한 문제점들이 생기지 않는다.
  - 따라서 CPU 대기 시간 및 사용량에 있어서도 대단히 효율적이다.
- 하지만 Non-Blocking I/O 방식에도 단점이 존재한다.
  1. 만약에 스레드 내부에 **CPU 를 많이 사용하는 작업이 포함된 경우에는 성능에 악영향**을 준다.
  2. 사용자의 요청에서 응답까지 전체 과정에 Blocking I/O 요소가 포함된 경우에는 Non-Blocking 의 이점을 발휘하기 힘들다.
> 완전한 Non-Blocking I/O(Fully Non-Blocking I/O)
> - 예를 들어 클라이언트 A라는 서버에 요청을 보낼 때, A 서버 혼자서 클라리언트의 요청을 처리하는 경우도 있지만 A 서버에서 데이터베이스의 테이블을 조회하고, 조회된 결과를 기반으로 다시 B와 C 서버로 요청을 보내서 B와 C 서버에서 처리된 결과를 취합한 후, 최종 결과를 생성해서 클라이언트에게 응답으로 보내는 그런 복잡한 요청 처리 과정이 있는 경우도 많을 것이다.
> - 이 경우 데이터베이스의 테이블을 조회할 때 발생하는 DB I/O와 B, C 서버에 요청할 때 발생하는 네트워크 I/O 등이 모두 Non-Blocking I/O 여야지만 제데로 된 Non-Blocking I/O 방식의 이점을 발휘할 수 있다.
> - 어느 하나라도 Blocking I/O 요소가 존재한다면 스레드가 차단되면서 병목 구간이 발생할 수밖에 없기 때문이다.
### 3.3. Spring Framework 에서의 Blocking I/O와 Non-Blocking I/O
- Spring MVC 기반의 웹 애플리케이션은 Blocking I/O 방식을 사용한다.
  - 스마트폰이나 테블릿 등 휴대기기, IOT 기술 등의 발전으로 Blocking I/O 방식의 애플리케이션이 감당하기 힘들 만큼의 트래픽이 발생하는 상황이 많아졌다.
  - 이러한 문제점을 극복하기 위해서 등장한것이 바로 **Spring Webflux**이다.
- Spring MVC 와 Spring Webflux 의 가장 큰 차이점은 Spring MVC 는 Blocking I/O 방식이고 Spring Webflux 는 Non-Blocking I/O 방식이라는 점이다.
  - 또한 서블릿 컨테이너 기반의 Spring MVC 는 요청당 하나의 스레드를 사용하기 때문에 대량의 요청을 처리하기 위해서 과도한 스레드를 사용함으로써 CPU 대기 시간이 늘어나고 메모리 사용 시 오버헤드가 발생한다.
  - 반면에 Spring Webflux 는 Netty 같은 비동기 Non-Blocking I/O 기반의 서버 엔진을 사용함으로써 적은 수의 스레드로 많은 수의 요청을 처리하기 때문에 CPU 와 메모리를 효율적으로 사용할 수 있어 결과적으로 적은 컴퓨팅 파워로 고성능의 애플리케이션을 운영할 수 있게 해준다.
> #### 정리하기
> - Blocking I/O의 특징
>   - Non-Blocking I/O는 작업 스레드의 작업이 종료될 때까지 요청 스레드가 차단된다.
>   - 스레드가 차단되는 문제를 보완하기 위해 멀티스레딩 기법을 사용할 수 있다.
>   - 멀티스레딩 기법 사용 시 컨텍스트 스위칭 전환 비용, 메모리 사용 오버헤드, 스레드 풀의 응답 지연 등의 문제가 발생할 수 있다.
> - Non-Blocking I/O의 특징
>   - 작업 스레드의 종료 여부와 상관없이 요청 스레드가 차단되지 않는다.
>   - 적은 수의 스레드만 사용해 스레드 전환 비용이 적으므로, CPU 를 효율적으로 사용할 수 있다.
>   - CPU 를 많이 사용하는 작업의 경우에는 성능의 악역향을 미칠 수 있다.
>   - 사용자 요청 처리에서 응답까지 전 과정이 Non-Blocking 이어야 제데로 된 효과를 얻을 수 있다.
### 3.4. Non-Blocking I/O 방식의 통신이 적합한 시스템
- Spring Webflux 도입하기 위한 고려사항
> 1. **학습 난이도가 높다.**
>   - DI(Dependency Injection), AOP(Aspect Oriented Programming), 서비스 추상화 등 Spring Framework 에서 사용되는 핵심 개념들을 어느 정도 이해하고 있다는 가정하에 Spring MVC 기반의 개발 방식은 Spring Webflux 에 비해서 상대적으로 학습 난이도가 낮다.
>   - Spring Webflux 의 핵심이 되는 리액티브 스트림즈라는 표준 사양을 구현한 구현체를 능숙하게 사용하기까지 학습에 대한 노력과 시간이 상당히 많이 필요하다고 생각한다.
> 2. **리액티브 프로그래밍 경험이 있는 개발 인력을 확보하는 것이 과연 쉬운가 하는 점이다.**
>   - 선언형 프로그래밍이자 Non-Blocking I/O 방식인 리액티브 프로그래밍 지식을 갖춘 숙련된 개발 인력을 확보하는 것은 상대적으로 어렵다.
>   - 위와 같은 이유로 Spring MVC 기반의 프로젝트는 안정적을 진행될 가능성이 높지만, Spring Webflux 기반의 프로젝트는 개발 인력 면이나 기술적 측면에서 위험 부담을 더 감수해야 될 가능성이 높다. 
#### 3.4.1. 대량의 요청 트래픽이 발생하는 시스템
- 일반적으로 애플리케이션에 발생하는 요청 트래픽이 충분히 감당할 수준이라면 서블릿 기반의 Blocking I/O 방식의 애플리케이션으로 충분하다고 생각한다.
- 하지만 대량의 요청 트래픽으로 자주 애를 먹는 시스템이라면 Spring Webflux 기반 애플리케이션으로의 전환을 고려해 볼 만하다.
  - 물론 서버 증설이나 VM 확장 등을 통해 트래픽을 분산할 수 있겠지만 그만큼의 높은 비용을 지불해야 할 가능성이 높다.
- Spring Webflux 기반 애플리케이션은 상대적으로 적은 컴퓨팅 파워를 사용함으로써 저비용으로 고수준의 성능을 이끌어 내는 괜찮은 선택이 될 수 있을 것이라 생각한다.
#### 3.4.2. 마이크로 서비스 기반 시스템
- 마이크로 서비스 기반의 시스템은 시스템의 특성상 서비스들 간에 많은 I/O 가 지속적으로 발생한다.
  - 따라서 특정 서비스들 간의 통신에서 Blocking 으로 인한 응답 지연이 발생하게 된다면 해당 서비스뿐만 아니라 다른 서비스들에도 영향을 미칠 가능성이 높다.
  - 심지어 응답 지연의 연쇄 작용으로 시스템 자체가 마비될 수 도 있다.
  - 그렇기 때문에 마이크로 서비스 기반 시스템에서는 Spring Webflux 같은 Non-Blocking I/O 방식의 기술이 반드시 필요하다고 볼 수 있다.
#### 3.4.3. 스트르밍 또는 실시간 시스템
- 리액티브 프로그래밍은 HTTP 통신이나 데이터베이스 조회와 같은 일회성 연결 뿐만 아니라 끊임없이 들어오는 무한한 데이터 스트림을 전달받아서 효율적으로 처리할 수 있따.
- Spring Webflux 를 이용하면 이러한 무한 데이터 스트림을 처리하기 위한 스트리밍 또는 실시간 시스템을 쉽게 구축할 수 있다.
> #### 정리하기
> - Spring Webflux 를 도입하기 적합한 시스템
>   - Blocking I/O 방식으로 처리하는 데 한계가 있는 대량의 요청 트래픽이 발생하는 시스템
>   - 마이크로 서비스 기반 시스템
>   - 스트리밍 시스템 또는 실시간 시스템