## MySQL
- MySQL(1995~)
  - 2008 | 썬 마이크로시스템즈가 인수
  - 2010 | 오라클이 인수
  - **싸다.**
  - 2000년대 중후반 부터 데이터의 특성이 변해가고 있음
    - SNS 서비스
    - 사물 인터넷
    - 빅 데이터 (모든 정보를 수집해서 분석)
  - 소규모 장비를 Scale-Out 해서 사용하는데 적합 (복제, 샤딩)
  - MySQL InnoDB의 성능, 기능은 타 DBMS와 비교해서 뒤쳐지지 않는다.
  - Plug-in 방식의 스토리지 엔진
  - MariaDB
  - MS-SQL에 비해서 다양한 플랫폼을 지원한다.


### InnoDB 스토리지 엔진
- 5.5부터 기본 스토리지 엔진으로 지정
- 트랜잭션 지원 (bulit-in 중에서는 유일)
- 레코드(row) 기반의 lock을 제공
  - 높은 동시성 처리 가능하고 안정적이면 성능이 뛰어남
- Primary key에 의한 클러스터링
  - InnoDB의 모든 테이블을 PK를 기준으로 클러스터링 되어 저장된다
    - 디스크 상에 저장될 때 PK 순서대로 저장한다.
- MVCC(Multi Version Concurrency Control) 기술을 사용해 락을 걸지 않고 일관된 읽기 작업을 수행
  - MVCC : 하나의 레코드(row)에 대해 여러 개의 버전이 동시에 관리된다.
  - 다른 트랜잭션이 가지고 있는 락을 기다리지 않고 읽을 수 있다.
  - 언두(Undo) 로그를 사용해서 지원
- MylSAM 에 비해 월등한 성능
- 외래 키 지원
  - 하지만 실무에서는 잘 사용되지 않음

### I/O
#### 디스크에서 데이터 읽기
- 디스크에서 데이터를 읽기 위해서는
  1. 데이터가 저장된 트랙으로 헤더 이동
  2. 플래터가 돌아갈 때 데이터가 저장된 섹터가 지나가기를 기다림
  3. 데이터를 읽음

#### 저장 장치별 성능
- 주요 저장 장치들이 요청된 작업르 처리하는데 소요되는 시간
  - 메모리 디스크의 처리 속도는 100,000배 이상의 차이
  - 메모리와 SSD는 1,000배 정도의 차이

#### 랜덤 I/O와 순차 I/O
- 3개의 페이지(16KB x 3)를 기록하기
  - 순차 I/O : 1번의 시스템 콜을 요청
    - 디스크 헤드를 1번 이동
  - 랜덤 I/O : 3번의 시스템 콜을 요청
    - 디스크 헤드를 3번 이동
- DBMS는 랜덤 I/O를 통한 작은 데이터 I/O가 대부분
> **데이터베이스의 성능을 높이기 위해서는 I/O (특히 랜덤)를 줄여야 함.**

### Index
- 책의 색인, 찾아보기
  - 책 내용은 "데이터 파일(테이블)"
  - "색인 항목"은 저장된 위치의 페이지 번호를 가짐.
- 테이블의 모든 내용을 검색하려면 시간이 오래 걸림
  - 컬럼(들)의 값과 저장된 주소를 key-value 쌍으로 저장
- 미리 정렬되어 있음 => 빠름
  - 데이터를 찾을 때는 이미 정렬되어 있어 => 빠른 검색(비용 감소)
  - 데이터를 저장할 때 마다 값을 정렬해야함 => 느림(비용 증가)
- 데이터를 저장(CUD) 성능을 희생하고 읽기(R) 성능을 높임
  - trade-off 관계이므로 인덱스의 추가는 상황에 맞게
- **B-Tree 알고리즘**
  - 가장 일반적으로 사용되는 인덱스 알고리즘. B??
  - InnoDB에서는 B+Tree를 사용
- Primary Key
  - == index, unique, not null
- Unique Key
  - == index, 보조 인덱스, unique, nullable
- Secondary Key
  - == index, 보조 인덱스

#### B+Tree
- MySQL에서 실제로 사용되는 트리 자료구조
- 모든 레코드들이 리프 노드에 정렬되어 있음
- 리프 노드들은 linked-list 형태로 서로 연결되어 있음.
- 블록 지향적인 스토리지 환경에서 효율적인 검색을 위해 데이터를 저장하는 방법


index를 확인하는 조건은?