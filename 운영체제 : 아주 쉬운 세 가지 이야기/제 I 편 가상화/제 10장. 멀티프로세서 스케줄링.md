# 제13장 멀티프로세서 스케줄링 (고급)

## 🎯 핵심 질문
- 여러 CPU에 작업을 어떻게 배분할 것인가?
- 단일 CPU 방식에서 무엇을 개선해야 하는가?

---

## 🧩 배경: 멀티코어의 대두
- 멀티코어 프로세서가 대중화되며 병렬 처리 필요성 증가
- 전통적인 프로그램은 하나의 CPU만 사용함
- 병렬 처리 → 멀티 스레드 + 멀티 CPU 스케줄링 필요

---

## 🧠 주요 개념

### 🧷 캐시 일관성 문제
- 여러 CPU가 동일한 메모리 주소를 캐시에 보유 시 일관성 충돌 발생
- 버스 스누핑, invalidation 등 하드웨어 기법으로 해결

### 🪢 동기화 필요성
- 여러 CPU가 공유 구조체 접근 시 락 필요
- 락 없으면 race condition 발생

---

## 🧠 문제 1: 캐시 친화성
- 동일한 프로세스를 동일한 CPU에서 재실행 → 캐시 적중률 향상
- CPU가 자주 바뀌면 성능 저하

---

## ⚙️ 스케줄링 기법

### 🟦 단일 큐 멀티프로세서 스케줄링 (SQMS)
- 모든 CPU가 하나의 공유 큐 사용
- 구현 쉬움, 하지만 락 경합과 캐시 친화성 문제 존재

### 🟩 멀티 큐 멀티프로세서 스케줄링 (MQMS)
- 각 CPU가 자체 큐를 가짐
- 락 경합 감소, 캐시 친화적
- ❗ 워크로드 불균형 문제 발생 가능

---

## 🔁 해결책: 작업 이주 (Migration)
- 유휴 CPU로 작업 이동하여 부하 분산
- **작업 훔치기 (Work Stealing)**: 가벼운 큐가 무거운 큐에서 작업을 가져옴

---

## 🐧 Linux 예시
- O(1) 스케줄러: MLFQ 기반
- CFS: 보폭 기반 비례배분
- BFS: 단일 큐 기반 비례배분 + 복잡한 기법 (EEVDF)

---

## 🧠 요약
- 멀티프로세서 환경에서는 확장성과 캐시 친화성 모두 중요
- MQMS + 이주 기법이 현실적인 해법
- 현대 OS는 다양한 혼합 방식을 사용
