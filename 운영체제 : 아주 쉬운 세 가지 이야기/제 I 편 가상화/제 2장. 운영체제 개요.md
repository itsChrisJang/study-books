# 제 2장. 운영체제 개요
- 프로그램은 매우 단순한 일을 한다. 명령어를 실행한다. 
  - 프로세서는 명령어를 초당 수백만 번 (요즘은 수십억 번) 반입(fetch)하고, 해석(decode)하고 (즉, 무슨 명령어인지 파악하고), 실행(execute)한다.(즉, 두 수를 더하고, 메모리에 접근하고, 조건을 검사하고, 함수로 분기하는 등의 정해진 일을 한다). 
  - 명령어 작􏰂을 완료한 후 프로세서는 다음 명령어로, 또 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속한다.
- 프로그램을 쉽게 실행하고 (심지어 동시에 여러 발의 프로그램을 실행시킬 수도 있음), 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양 흥미로운 일을 할 수 있게 하는 소프트웨어가 있다. 
  - 시스템을 사용하기 편리하면서 정확하고 올􏰍르게 동작시킬 책임이 있기 때문에 소프트웨어를 운영체제(operating system, OS)라고 부른다.
- 운영체제는 가상화라고 불리는 기법을 사용한다.
  - 운영체제는 프로세서, 메모리 또는 디스크와 같은 물리적인 자원을 이용하여 일반적이고, 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다.
  - 이 때문에 때로는 가상 머신이라고 부른다.
- 사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에게 요청할 수 있도록, 운영체제는 사용자에게 API를 제공한다. 
  - 보통 운영체제는 응용 프로그램이 사용 가능한 수백 발의 시스템 콜을 제공한다.
- 마지막으로, 가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게 한다. 프로그램들이 각자 명령어와 데이터를 접근할 수 있게 한다. 
  - 프로그램들이 디스크 등의 장치를 공유할 수 있게 한다. 
  - 이러한 이유로 운영체제는 자원 관리자(resource manager)라고도 불린다. CPU, 메모리, 및 디스크는 시스템의 자원이다. 
  - 효율적으로, 공정하게, 이들 자원을 관리하는 것이 운영체제의 역할이다.
## 2.1 CPU 가상화
#### 반복해서 출력하는 코드
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include “common.h”

int
main(int argc, char *argv[])
{
    if (argc!=2) {
        fprintf(stderr,“usage: cpu <string>\n”);
        exit(1); 
    }
    char *str = argv[1];
    while (1) {
        Spin(1);
        printf(“%s\n”, str); 
    }
    return 0; 
}
```
#### 동시에 많은 프로그램 실행시키기
```shell
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D & [1] 7353
[2] 7354
[3] 7355
[4] 7356 A
B
D
C
A
B 
D 
C 
A 
C 
B 
D
```
- 프로세서가 하나밖에 없음에도 프로그램 4개 모두 동시에 실행되는 것처럼 보인다.
- 하드웨어의 도움을 받아 운영체제가 시스템에 매우 많은 수의 가상 CPU가 존재하는 듯한 **환상(illusion)**을 만들어 낸 것이다. 
  - 하나의 CPU 또는 소규모 CPU 집합을 무한 발의 CPU가 존재하는 것처럼 변환하여 동시에 많은 수의 프로그램을 실행시키는 것을 **CPU 가상화(virtualizing the CPU)**라 한다.
- 프로그램을 실행하고, 멈추고, 어떤 프로그램을 실행시킬 것인가를 운영체제에게 알려주기 위해서는 원하는 􏰍를 운영체제에 전달할 수 있는 인터페이스(API)가 필요 하다.
- 다수의 프로그램을 동시에 실행시킬 수 있는 기능은 새로운 종류의 문제를 발생시킨다는 것을 인지했을 것이다. 
  - 예를 들어, 특정 순간에 두 발의 프로그램이 실행되기를 원한다면, 누가 실행되어야 하는가? 
    - 이 질문은 운영체제의 정책 (policy)에 달려있다.

```cpp
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include “common.h”
int
main(int argc , char *argv[])
{ 
  int *p = malloc(sizeof(int)); // a1 assert(p != NULL);
  printf(“(%d) memory address of p: %08x\n”,
    getpid(), (unsigned) p); // a2 *p = 0; // a3
  while (1) {
    Spin(1);
    *p = *p + 1;
    printf(“(%d) p: %d\n”, getpid(), *p); // a4 
  }
  return 0; 
}

```

## 2.2 메모리 가상화
- 현재 우리가 사용하고 있는 컴퓨터에서의 물리 메모리(physical memory) 모델은 매우 단순하다.
  - 바이트의 배열이다.
  - 메모리를 읽기 위해서는 데이터에 **주소(address)**를 명시해야 한다.
- 메모리는 프로그램이 실행되는 동􏰏 항상 접근된다. 
  - 프로그램은 실행 중에 자신의 모든 자료 구조를 메모리에 유지하고 load와 store 또는 기타 메모리 접근을 위한 명령어를 통하여 자료 구조에 접근한다. 
  - 명령어 역시 메모리에 존재한다는 사실을 잊지 말자.
  - 명령어를 반입할 때마다 메모리가 접근된다.
```shell
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000 (24114) memory address of p: 00200000 (24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
```
- 프로그램들은 같은 주소에 메모리 를 할당되지만 (00200000), 각각이 독립적으로 00200000 번지의 값을 갱신한다. 
  - 각 프로그램은 물리 메모리를 다른 프로그램과 공유하는 것이 아니라 각자 자신의 메모리를 가지고 있는 것처럼 보인다.
- 운영체제가 메모리 가상화(virtualizing memory)를 하기 때문에 이런 현상이 생긴다. 
  - 각 프로세스는 자신만의 가상 주소 공간(virtual address space, 때로 그냥 주소 공간(address space)이라고 불림)을 갖는다.
  - 운영체제는 이 가상 주소 공간을 컴퓨터의 물리 메모리로 매핑(mapping)한다. 
  - 하나의 프로그램이 수행하는 각종 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않는다. 
  - 실행 중인 프로그램의 입장에서는, 자기 자신만의 물리 메모리를 갖는 셈이다. 
  - **실제로는 물리 메모리는 공유 자원이고, 운영체제에 의해 관리**된다.

## 2.3 병행성
- 프로그램이 한 번에 많은 일을 하려 할 때 (즉, 동시에) 발생하는 그리고 반드시 해결해야 하는 문제들을 가리킬 때 병행성이라는 용어를 사용한다.
```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

volatile int counter = 0;
int loops;

void *worker(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        counter++;
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "usage: threads <value>\n");
        exit(1);
    }

    loops = atoi(argv[1]);
    pthread_t p1, p2;

    printf("Initial value : %d\n", counter);

    Pthread_create(&p1, NULL, worker, NULL);
    Pthread_create(&p2, NULL, worker, NULL);
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);

    printf("Final value : %d\n", counter);
    return 0;
}
```
```shell
prompt> ./thread 100000 
Initial value : 0
Final value : 143012 // 왜?
prompt> ./thread 100000 
Initial value : 0
Final value : 137298 // 뭐라고?
```
- 이번 실행에서는 입력 값을 100,000으로 주었더니 최종 값이 200,000이 아니라 143,012가 되었다. 
  - 다시 한 번 동일한 조건으로 실행시켰을 때에는 또 잘못된 값이 출력되었을 뿐 아니라 직전 실행과도 다른 결과가 출력되었다. 
- 예상하지 못한 결과의 원인은 명령어가 한 번에 하나씩만 실행된다는 것과 관련 있다. 
  - 앞 프로그램의 핵심 부분인 counter를 증가시키는 부분은 세 발의 명령어로 이루어진다. 
  - counter 값을 메모리에서 레지스터로 탑재하는 명령어 하나, 레지스터를 1 증가시키는 명령어 하나, 레지스터의 값을 다시 메모리에 저장하는 명령어 하나 이렇게 3발의 명령어로 구성된다. 
    - **이 세 발의 명령어가 원자적(atomically)**으로(한 번에 3발 모두) 실행되지 않기 때문에 이상한 일이 발생할 수 있다.

## 2.4 영속성
- DRAM과 같은 장치는 데이터를 휘발성(volatile) 방식으로 저장하기 때문에 메모리의 데이터는 쉽게 손실될 수 있다. 
  - 전원 공급이 끊어지거나 시스템이 갑자기 고장나면(crash) 메모리의 모든 데이터는 사라진다. 
  - 데이터를 영속적으로 저장할 수 있는 하드웨어와 소프트웨어가 필요하다. 
  - **저장 장치는 모든 시스템에 필수적**이다.
- 하드웨어는 입력/출력(input/output) 혹은 I/O 장치 형태로 제공된다. 
  - 요즘에는 solid-state drives(SSDs)가 많이 사용되고 있기는 하지만 장기간 보존할 정보를 저장하는 장치로는 일반적으로 하드 드라이브(hard drive)가 사용된다.
- 디스크를 관리하는 운영체제 소프트웨어를 파일 시스템(file system)이라고 부른다. 
  - 파일 시스템은 사용자가 생성한 **파일(file) 시스템**의 디스크에 􏰏전하고 효율적인 방식으로 저장할 책임이 있다.