# Chapter 11 CPU 스케줄링
## 11-1. CPU 스케줄링
- 모든 프로세스는 CPU를 필요로 하고 모든 프로세스는 먼저 CPU를 사용하고 싶어 한다.
  - 이러한 프로세스들에서 공정하고 합리적으로 CPU 자원을 할당하기 위해 운영체제는 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 기다리게 할지를 결정한다.
- 이러한 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 **CPU 스케줄링(CPU scheduling)** 이라고 한다.
  - CPU 스케줄링은 컴퓨터 성능과도 직결되는 중요한 문제이다.
  - 프로세스들에게 현명하게 CPU를 배분하지 못하면 반드시 실행되어야 할 프로세스들이 실행되지 못하거나, 당장 급하지 않은 프로세스들만 주로 실행되는 등 무질서한 상태가 발생할 수 도 있기 때문이다.

### 프로세스 우선순위
- 아주 단순하게 CPU를 사용하고 싶어 하는 프로세스들이 차례로 돌아가며 CPU를 이용하게 하는 방법이 있다.
  - 즉, "CPU를 사용하고 싶어요!"라고 먼저 말한 프로세스 순서대로 CPU를 이용하게 하는 방법이다.
  - 언뜻 들으면 합리적인 방식인거 같지만, 좋은 방법이 아니다.
  - 그 이유는 **프로세스마다 우선순위가 다르기 떄문** 이다.
    - 우선순위가 높은 프로세스란 빨리 처리해야 하는 프로세스들을 의미한다.
    - 우선순위가 높은 프로세스에는 대표적으로 입출력 작업이 많은 프로세스가 있다.
- Q: 입출력 작업이 많은 프로세스를 먼저 실행하는 것이 왜 더 효율적일까?
- A: 이를 이해하려면 일반적인 프로세스가 어떤 과정을 거치며 실행되는지 생각해야 한다.
  - 대부분 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행한다.
  - 다르게 말하면 프로세스는 실행 상태와 대기 상태를 반복하며 실행된다.
  - 예를 들어 워드 프로세서는 CPU를 사용하여 명령어를 실행하고, 사용자로부터 입력받은 내용을 보조기억장치에 저장하고, CPU를 사용하여 명령어를 실행하고, 사용자가 입력한 내용을 화면에 출력하는 과정을 반복하며 실행된다.
  - 그런데 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다.
  - 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스도 있고, 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스도 있다.
    - 전자를 **입출력 집중 프로세스(I/O bound process)** 라고 하고, 후자를 **CPU 집중 프로세스(CPU bound process)** 라고 한다.
  - 입출력 집중 프로세스는 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무르고 반대로 CPU 집중 프로세스는 대기 상태보다는 실행 상태에 더 많이 머무른다.

> #### 여기서 잠깐) CPU 버스트와 입출력 버스트
> - CPU를 이용히는 작업를 **CPU 버스트(CPU burst)** 라고 하고, 입출력장치를 기다리는 작업을 **입출력 버스트(I/O burst)** 라고 한다.
> - 즉, 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행된다고 볼 수 있다.
> - 그래서 입출력 집중 프로세스는 입출력 버스트가 많은 프로세스, CPU 집중 프로세스는 CPU 버스트가 많은 프로세스라고 정의할 수 있다.

- CPU 집중 프로세스는 CPU를 많이 사용해야 하는 프로세스이고, 입출력 집중 프로세스는 그렇지 않은 프로세스인데, CPU 집중 프로세서와 입출력 집중 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비합리적이다.
- CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다 가정하자.
  - 이러한 경우 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다.
  - 입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있기 때문이다.
- 상황에 맞게, 그리고 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있또록 하기 위해 운영체제는 프로세스마다 **우선순위(priority)** 를 부여한다.
  - 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다,
  - 그렇게 자연스럽게 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행된다.

> #### 여기서 잠깐) 프로세스 우선순위 직접 확인하기
> - 우선 순위가 높은 대표적인 프로세스는 입출력 작업이 많은 프로세스이지만 이외에도 우선순위가 높은 프로세스로는 실시간 프로세스, 일부 백그라운드 프로세스 등 다양하다.
> - 어떤 프로세스의 우선순위가 높고, 어떤 프로세스의 웅선순위가 낮은지 직접 확인해보자.
    >   - 유닉스, 리눅스, macOS 등의 유닉스 체계 운영체제에서는 ps -el 명령을 통해 확인이 가능하다.
>   - nice 명령어를 통해서 일부 프로세스의 우선순위를 변경할 수도 있다.

### 스케줄링 큐
- PCB에 우선순위가 적혀 있지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤척거리는 것은 비효율적이다.
  - CPU를 원하는 프로세스들은 한 두 개가 아니고, CPU를 요구하는 새로운 프로세스는 언제든 생길 수 있기 때문이다.
- 이는 비단 CPU 자원에만 국한된 상황이 아니다.
  - 메모리에 적재되고 싶어 하는 프로세스도 얼마든지 있을 수 있고, 특정 입출력장치와 보조기억장치를 사용하길 원하는 프로세스도 여러 개가 있을 수 있다.
  - 운영체제가 매번 일일이 모든 PCB를 검사하여 먼저 자원을 이용할 프로세스를 결정하는 일은 매우 번거로울뿐더러 오랜 시간이 걸리는 일이다.
- 그렇기에 운영체제는 프로세스들에 '줄을 서서 기다릴 것'을 요구한다.
  - CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄 세우는 것이다.
  - 그리고 운영체제는 이 줄을 **스케줄링 큐(scheduling queue)** 로 구현하고 관리한다.
> 큐는 자료 구조 관점에서 보았을 때는 먼저 삽입된 데이터가 먼저 나가는 선입선출(First In First Out) 자료 구조 이지만, 스케줄링에서 이야기하는 큐는 반드시 선입선출 방식일 필요는 없다.
- 즉, 운영체제는 메모리로 적재되고 싶은(새로 생성하는) 프로세스들을 큐에 삽입하여 줄을 세우고 CPU를 이용하고 싶은 프로세스들 또한 큐에 삽입하여 줄을 세우고, 특정 입출력장치를 이용하고 싶은 프로세스들 역시 큐에 삽입하여 줄을 세운다.
- 운영체제가 관리하는 대부분의 자원은 이렇듯 큐로 관리된다.
  - 그래서 운영체제가 관리하는 줄, 즉 큐에는 다양한 종류가 있다.
  - 대표적인 큐로 준비 큐와 대기 큐가 있다.
    - **준비 큐(ready queue)**
      - CPU를 이용하고 싶은 프로세스들이 서는 줄
    - **대기 큐(waiting queue)**
      - 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
- 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다린다.
  - 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행한다.
- 우선순위가 낮은 프로세스들이 먼저 큐에 삽입되어 줄을 섰다고 할지라도 우선순위가 높은 프로세스는 그들보다 먼저 처리될 수 있다.
  - 이런 점에서 봤을 때 높은 우선순위를 가진 프로세스는 마치 VIP와 같다.
- 대기 상태에 있는 프로세스도 마찬가지이다.
  - 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다린다.
  - 예를 들어 하드 디스크 사용을 요구한 프로세스는 하드 디크스 대기 큐에서 입출력 작업이 완료되기를 기다리고, 프린터 사용을 요구한 프로세스는 프린터 대기 큐에서 입출력 작업이 완료되기를 기다린다.
- 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거한다.

### 선점형과 비선점형 스케줄링
- Q: 갑자기 다른 급한 프로세스가 CPU를 지금 당장 사용하길 요청한다면 어떻게 해야할까?
- A: 이런 상황에서 선택할 수 있는 방법은 두가지이다.
  - 지금 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당할 수도 있고, CPU를 사용 중인 프로세스의 작업이 끝날 때까지 다른 급한 프로세스를 기다리게 할 수도 있다.
  - 이 방법을 각각 선점형 스케줄링과 비선점형 스케줄링이라 한다.
- 선점이란 '남보다 앞서서 차지함'을 의미한다.
  - **선점형 스케줄링(preemptive scheduling)** 은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식을 의미한다.
  - 다시 말해 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식이다.
  - 프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 타이머 인터럽트가 발생하면 운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식은 선점형 스케줄링의 일종으로 볼 수 있다.
- 반면 **비선점형 스케줄링(non-preemptive scheduling)** 이란 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 의미한다.
  - 다시 말해 비선점형 스케줄링은 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식이라 볼 수 있다.
  - 만약 비선점형 스케줄링 방식으로 자원을 이용하는 프로세스가 있다면 다른 프로세스들은 그 프로세스의 사용이 모두 끝날 때까지 기다려야 한다.
- 현재 대부분의 운영체제는 선점형 스케줄링 방식을 차용하고 있지만, 선점형 스케줄링과 비선점형 스케줄링은 각기 장단점을 가지고 있다.
  - **선점형 스케줄링** 은 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.
  - 반면 **비선점형 스케줄링** 은 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수밖에 없다.
  - 모든 프로세스가 골고루 자원을 사용할 수 없다는 단점이 있다.

---