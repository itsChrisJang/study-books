# Chapter 14 가상 메모리
## 14-3. 페이지 교체와 프레임 할당
- 가상 메모리를 통해 작은 물리 메모리보다 큰 프로세스도 실행할 수 있다고는 하지만 그럼에도 불구하고 여전히 물리 메모리의 크기는 한정되어 있다.
  - 운영체제는 프로세스들이 한정된 메모리를 효율적으로 이용할 수 있도록 기존에 메모리에 적재된 불필요한 페이지를 선별하여 보조기억장치로 내보낼 수 있어야 하고, 프로세스들에 적절한 수의 프레임을 할당하여 페이지를 할당할 수 있게 해야 한다.

### 요구 페이징
- 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법을 **요구 페이징(demand paging)** 이라고 한다.
  - 이름 그대로 실행에 요구되는 페이지만 적재하는 기법이다.
- 요구 페이징의 기본적인 양상
  1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
  2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다.
  3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) 페이지 폴트가 발생한다.
  4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
  5. 다시 (i) 번을 수행한다.
- 참고로 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 할 수도 있다.
  - 이 경우 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하게 되고, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어진다.
  - 이를 **순수 요구 페이징(pure demand paging)** 기법이라 한다.
- 요구 페이징 시스템이 안정적으로 작동하려면 필연적으로 다음 두 가지룰 해결해야 한다.
  - 하나는 **페이지 교체** 이고, 다른 하나는 **프레임 할당** 이다.
- 요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 차게 된다.
  - 이때는 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다.
- 메모리에 적재된 많고 많은 페이지 중 어떤 페이지를 보내는 것이 최선일까?
  - 이를 결졍하는 방법이 페이지 교체 알고리즘이다.
  - 즉, 쫓아낼 페이지를 결정하는 방법을 **페이지 교체 알고리즘** 이라 한다.

### 페이지 교체 알고리즘
- 좋은 페이지 교체 알고리즘은 무엇일까?
  - 일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가한다.
  - 페이지 폴트가 일어나면 보조기억장치로부터 필요한 페이지를 가져와야 하기 떄문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문이다.
- 가령 한 알고리즘을 통해 고른 페이지를 스왑 아웃시켰을 때 페이지 폴트가 자주 발생하면 이는 좋은 알고리즘이 아니다.
  - "한 페이지 교체 알고리즘을 선택했더니 페이지 폴트가 자주 발생했다."는 말은 "보조기억장치로 내쫓을 페이지를 잘못 골랐다"는 뜻으로, 내보내면 안 되는 페이지를 보조기억장치로 내보냈다는 의미와 같기 때문이다.
  - 반면, 어떤 알고리즘을 통해 고른 페이지를 스왑 아웃시켜도 페이지 폴트가 자주 발생하지 않는다면 이는 컴퓨터의 성능 저하를 방지하는 좋은 알고리즘으로 평가할 수 있다.
- 그렇기에 페이지 교체 알고리즘을 제데로 이해하려면 **페이지 폴트 횟수** 를 알 수 있어야 한다.
  - 그리고 페이지 폴트 횟수는 **페이지 참조열(page reference string)** 을 통해 알 수 있다.

#### FIFO 페이지 교체 알고리즘(First-In First-Out Page Replacement Algorithm)
- 이름 그대로 가장 먼저 올라온 페이지부터 내쫓는 방식으로, 쉽게 말해 "오래 머물렀다면 나가라"는 알고리즘이다.
- FIFO 페이지 교체 알고리즘은 아이디어와 구현이 간단하지만, 마냥 좋은 것은 아니다.
  - 프로그램 실행 초기에 적재된 페이지 속에는 프로그램 실행 초기에 잠깐 실행되다가 이후에 사용되지 않을 페이지도 있겠지만, 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있다.

#### 최적 페이지 교체 알고리즘(optimal page replacement algorithm)
- 최적 페이지 교체 알고리즘은 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다.
  - 메모리에 오랫동안 남아야 할 페이지는 자주 사용될 페이지고, 반대로 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지인데, 오랜 기간 메모리에 있었던 페이지라고 해서 보조기억장치로 내쫓는 건 비합리적이라고 볼 수 있다.
  - 따라서 보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 낮은 페이지이므로, 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 삼는 것이 가장 합리적이다.
    - 이 알고리즘이 **최적 페이지 교체 알고리즘** 이다.
  - 최적 페이지 교체 알고리즘은 이름 그대로 가장 낮은 페이지 폴트율을 보장하는 알고리즘이다.
    - 그렇기에 최적 페이지 교체 알고리즘은 위 예시뿐 아니라 다른 페이지 참조열을 바탕으로 실험해 보아도 타 페이지 교체 알고리즘에 비해 페이지 폴트 발생 빈도가 가장 낮다.
  - 다만, 최적 페이지 교체 알고리즘은 실제 구현이 어렵다.
    - 최적 페이지 교체 알고리즘은 앞으로 오랫동안 사용되지 않을 페이지를 내보내는 알고리즘이다.
    - 하지만, '앞으로 오랫동안 사용되지 않을 페이지'를 예측하기 어렵다.
    - 프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 미리 알아야 하는데, 이는 현실적으로 불가능에 가깝다.
    - 따라서 최적 페이지 교체 알고리즘은 그 자체를 운영체제에서 사용하기보다는, 주로 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용된다.
    - 즉, 최적 페이지 교체 알고리즘을 실행했을 때 발생하는 페이지 폴트 횟수를 페이지 폴트의 하한선으로 간주하고, 최적 페이지 교체 알고리즘에 비해 얼만큼 페이지 폴트 횟수가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용한다.

#### LRU 페이지 교체 알고리즘(LRU: Least Recently Used Page Replacement Algorithm)
- 최적 페이지 교체 알고리즘은 구현하기 어려워도 이와 비슷한 알고리즘을 만들 수 있다.
- 가장 오랫동안 사용되지 '않을' 페이지를 교체하는 알고리즘을 구현하기 어렵다면, 이를 조금 변형한 가장 오랫동안 사용되지 '않은' 페이지를 교체하는 알고리즘은 구현이 가능하다.
  - 이 알고리즘이 **LRU 페이지 교체 알고리즘** 이다.
- LRU 페이지 교체 알고리즘은 '최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것'이라는 아이디어를 토대로 만들어진 알고리즘이다.
  - 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체한다.

### 스래싱과 프레임 할당
- 페이지 폴트가 자주 발생하는 이유에 나쁜 페이지 교체 알고리즘만 있는 건 아니다.
- 프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생한다.
  - 사실 이것이 더 근본적인 이유라 할 수 있다.
- 반대로 프로세스가 사용할 수 있는 프레임 수가 많으면 일반적으로 페이지 폴트 빈도는 감소한다.
- 극단적으로 프레임이 무한히 많은 컴퓨터와 프레임이 한 개 있는 컴퓨터를 비교해보자.
  - 전자는 페이지를 수용할 공간이 넉넉하여 모든 프로세스의 페이지가 메모리에 적재될 수 있기 때문에 페이지 폴트 발생 빈도가 적지만, 후자는 새로운 페이지를 참조할 때마다 페이지 폴트가 발생한다.
- 이처럼 프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수밖에 없다.
  - 실행의 맥이 탁 탁 끊기고, 결과적으로 CPU의 이용률도 떨어진다.
  - CPU가 쉴새 없이 프로세스를 실행해야 컴퓨터 전체의 생산성도 올라갈 텐데, 페이지 교체에 너무 많은 시간을 쏟으면 당연히 성능에도 큰 악영향이 초래된다.
  - 이처럼 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 **스래싱(thrashing)** 이라 한다.
- 스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다.
  - 가령 프로세스 A를 무리 없이 실행하기 위해서는 최소 열 개의 프레임이 필요한데도 불구하고 프로세스 A가 다섯 개의 프레임만 이용할 수 있다면 이 프로세스는 페이지 폴트가 자주 발생한다.
  - 즉, 스래싱 발생 위험이 높아진다.
  - 그렇기에 운영체제는 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 한다.
- 우선 가장 단순한 형태의 **프레임 할당 방식** 부터 생각해보자.
  - 모든 프로세스에 균등하게 프레임을 제공하는 방식을 생각해보자.
  - 가령 세 개의 프로세스에 총 300개의 프레임을 할당할 수 있다면 각 프로세스에 100개의 프로세스를 할당하는 방식이다.
    - 이러한 프레임 할당 방식을 **균등 할당(equal allocation)** 이라 한다.
  - 하지만 짐작할 수 있다시피 균등 할당은 권장하는 방법이 아니다.
    - 실행되는 프로세스들의 크기는 각기 다르고, 천편일률적으로 동일한 프레임 개수를 할당하는 것은 비합리적이다.
    - 가령 크기가 상대적으로 큰 워드 프로세서와 상대적으로 작은 메모장이 동시에 실행된다면 워드 프로세서에 프레임을 더 많이 할당해 주고, 메모장에는 상대적으로 작은 메모장이 동시에 실행된다면 워드 프로세서에 프레임을 더 많이 할당해 주고, 메모장에는 상대적으로 적은 프레임을 할당하는 것이 더 합리적이다.
    - 이렇게 프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠 주는 방식을 **비례 할당(proportional allocation)** 이라 한다.
  - 하지만 비례 할당 또한 완벽한 방식은 아니다.
    - 프로세스의 크기가 클지라도 막상 실행해 보니 많은 프레임을 필요로 하지 않는 경우도 있다.
    - 반대로 프로세스의 크기가 작아도 실행해 보니 많은 프레임을 필요로 하는 경우도 있다.
    - 즉, 하나의 프로세스가 실제로 얼마나 많은 프레임이 필요할지는 결국 실행해 봐야 아는 경우가 많다.
- 프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식에는 크게 **작업 집합 모델(working set model)** 을 사용하는 방식과 **페이지 폴트 빈도(PFF: Page-Fault Frequency)** 를 사용하는 방식이 있다.
  - 작업 집합 모델 기반 프레임 할당
    - 스래싱이 발생하는 이유는 빈번한 페이지 교체 때문이다.
    - 그렇기에 작업 집합 모델 기반 프레임 할당 방식은 '프로세스가 일정 기간 동안 참조할 페이지 집합'을 기억하여 빈번한 페이지 교체를 방지한다.
    - CPU가 메모리를 참조할 때에는 참조 지역성의 원리에 의거해 주로 비슷한 구역을 집중적으로 참조한다.
      - 한 프로세스가 100개의 페이지로 이루어졌다고 해서 100개를 모두 고르게 참조하는 것이 아니라, 특정 시간 동안에는 몇몇개의 페이지(정확히는 몇 개의 페이지 내 주소들)만을 집중적으로 참조하게 된다.
    - 그렇다면 CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 페이지 교체는 빈번하게 발생하지 않겠죠?
      - 만약 CPU가 어떤 프로세스를 실행하는 동안 3초에 일곱 개의 페이지를 집중적으로 참조헀다면 운영체제는 그 프로세스를 위해 그 순간만큼은 최소 일곱 개의 프레임을 할당하면 된다.
      - 또 만약 CPU가 어떤 프로세스를 실행하는 동안 3초에 20개의 페이지를 집중적으로 참조헀다면 운영체제는 그 프로세스를 위해 그 순간만큼은 최소 20개의 프레임을 할당하면 된다.
    - 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 **작업 집합(working set)** 이라 한다.
    - CPU가 과거에 주로 참조한 페이지를 작업 집합에 포함한다면 운영체제는 작업 집합의 크기만큼만 프레임을 할당해 주면 된다.
  - 페이지 폴트 기반 프레임 할당
    - 아래 두 개의 가정에서 생겨난 아이디어이다.
      1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.
      2. 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있다.
    - 즉, 페이지 폴트 기반 프레임 할당 방식은 페이지 폴트율에 상한선과 하한선을 정하고, 이 범위 안에서만 프레임을 할당하는 방식이다.

---