# Chapter 14 가상 메모리
## 14-1. 연속 메모리 할당
- 지금까지는 메모리 내에 프로세스들이 연속적으로 배치되는 상황을 가정했다.
  - 즉, 프로세스 A는 A의 크기만큼 메모리 주소를 할당받아 연속적으로 배치되고, 프로세스 B는 프로세스 A 이후에 또 B의 크기만큼 연속적인 메모리 주솔르 할당받아 배치되는 식으로 말이다.
- 이렇게 프로세스에 연속적인 메모리 공간을 할당하는 방식을 **연속 메모리 할당** 방식이라 한다.

### 스와핑
- 메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 있을 수 있다.
  - 입출력 작업의 요구로 대기 상태가 된 프로세스라던지, 오랫동안 사용되지 않은 프로세스가 이런 프로세스들에 속한다.
  - 이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 **스와핑(swapping)** 이라 한다.
- 이때, 프로세스들이 쫓겨나는 보조기억장치의 일부 영역을 **스왑 영역(swap space)** 라고 한다.
  - 그리고 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것을 **스왑 아웃(swap-out)**, 반대로 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 **스왑 인(swap-in)** 이라고 한다.
  - 스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와는 다른 주소에 적재될 수 있다.
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.
> #### 여기서 잠깐) 스왑 영역 확인하기
> - 유닉스와 리눅스, macOS에서는 free, top 명령어 등을 통해 스왑 영역의 크기를 확인할 수 있다.
> - 스왑 영역의 크기와 사용 여부는 사용자가 임의로 설정할 수 있다.

### 메모리 할당
- 프로세스는 메모리 내의 빈 공간에 적재되어야 한다.
  - Q: 메모리 내에 빈 공간이 여러 개 있다면 프로세스를 어디에 배치해야 할까?
  - A: 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식을 알아보자.
- 대표적으로 **최초 적합, 최적 적합, 최악 접합** 의 세 가지 방식이 있다.
  - **20MB 크기의 프로세스를 적재하고 싶다고 가정하자.**
  - 메모리의 사용자 영역은 총 200MB라고 가정하자.
  - 프로세스를 적재할 수 있는 빈 공간은 빈 공간 A, 빈 공간 B, 빈 공간 C 세 군대가 있다.

#### 메모리 예시

| 메모리       | 메모리 양 |
|-----------|-------|
| 프로세스 A    | 50MB  |
| 빈 공간 A    | 30MB  |
| 프로세스 B    | 30MB |
| 빈 공간 B    | 60MB   |
| 프로세스 C    | 10MB   |
| 빈 공간 C    | 20MB   |
---  

#### 최초 적합
- **최초 적합(first fit)** 은 운영체제 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.
  - 즉 운영체제가 빈 공간 A -> 빈 공간 B -> 빈 공간 C 순으로 빈 공간을 검색했다면 프로세스는 빈 공간 A에 적재된다.
  - 최초 적합 방식은 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화할 수 있고 결과적으로 빠른 할당이 가능하다.

| 메모리          | 메모리 양 |
|--------------|-------|
| 프로세스 A       | 50MB  |
| **적재할 프로세스** | 30MB  |
| 프로세스 B       | 30MB |
| 빈 공간 B       | 60MB   |
| 프로세스 C       | 10MB   |
| 빈 공간 C       | 20MB   |

#### 최적 적합
- **최적 적합(best fit)** 은 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.
- 앞의 예시에서 프로세스가 적재도리 수 있는 빈 공간 중 가장 작은 공간은 빈 공간 C이다.
- 그렇기에 최적 적합 방식으로 메모리를 할당하면 프로세스는 빈 공간 C에 할당한다.

| 메모리          | 메모리 양 |
|--------------|-------|
| 프로세스 A       | 50MB  |
| 빈 공간 A       | 30MB  |
| 프로세스 B       | 30MB |
| 빈 공간 B       | 60MB   |
| 프로세스 C       | 10MB   |
| **적재할 프로세스** | 20MB   |

#### 최악 적합
- **최악 적합(worst)** 은 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.
- 앞선 예시에서 프로세스가 적재될 수 있는 빈 공간 중 가장 큰 공간은 빈 공간 B이다.
- 그렇기에 최악 적합 방식으로 메모리를 할당하면 프로세스는 빈 공간 B에 할당된다.

| 메모리       | 메모리 양 |
|-----------|-------|
| 프로세스 A    | 50MB  |
| 빈 공간 A    | 30MB  |
| 프로세스 B    | 30MB |
| **적재할 프로세스**    | 60MB   |
| 프로세스 C    | 10MB   |
| 빈 공간 C    | 20MB   |

### 외부 단편화
- 프로세스를 메모리에 연속적으로 배치하는 연속 메모리 할당은 언뜻 들으면 당연하게 느껴질 수 있지만, 사실 이는 메모리를 효율적으로 사용하는 방법이 아니다.
  - 왜냐하면 연속 메모리 할당은 **외부 단편화(external fragmentation)** 라는 문제를 내표하기 있기 때문이다.
- 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다.
  - 프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다.
    - 이러한 현상을 **외부 단편화(external fragmentation)** 라고 한다.
- 위의 예시에서는 메모리에 프로세스가 몇 개 없는 간단한 상황을 가정했기에 외부 단편화가 큰 문제가 아닌 것처럼 보일 수 있지만, 실제로는 이보다 메모리 용량도 크고 적재되는 프로세스도 많기 때문에 외부 단편화로 인해 낭비되는 공간은 더욱 크다.
- 외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 **압축(compaction)** 하는 방법이 있다.
  - 메모리 조각 모음이라고도 부른다.
  - 압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈공간으로 만드는 방법이다.
  - 다만 압축 방식에는 여러가지 단점이 있다.
    - 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하며, 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어렵다.
- 외부 단편화를 없앨 수 있는 또 다른 해결 방안이 있다.
  - 가상 메모리 기법, 그중에서 페이징 기법이 오늘날까지 자주 사용된다.

---