# Chapter 14 가상 메모리
## 14-2. 페이징을 통한 가상 메모리 관리
- 프로세스를 메모리에 연속적으로 할당하는 방식은 두 가지 문제를 내포하고 있다.
  - 한 가지는 앞선 절에서 다뤘던 외부 단편화이고, 또 하나는 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점이다.
- **가상 메모리(virtual memory)** 는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
  - 이를 가능케 하는 메모리 관리 기법에는 크게 **페이징과 세그멘테티션** 이 있지만, 이 책에서는 운영체제가 사용하는 페이징 기법을 다룬다.
  - 페이징 기법을 이용하면 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만 아니라 앞선 절에서 배운 외부 단편화 문제도 해결할 수 있다.
  
### 페이징이란
- 연속 메모리 할당 방식에서 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다.
- 만일 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로도 할당할 수만 있다면 외부 단편화는 발생하지 않는다.
  - 이것은 **페이징(paging)** 이다.
  - 페이징은 프로세스의 논리 주소 공간을 **페이지(page)** 라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임(frame)** 이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
- 페이징에서도 스와핑을 사용할 수 있다.
  - 페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/스왑 인되는 것이 아닌 페이지 단위로 스왑 아웃/스왑 인된다.
  - 즉, 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃되고, 실행에 필요한 페이지들은 메모리로 스왑 인되는 것이다.
  - 페이징 시스템에서의 스왑 아웃은 **페이지 아웃(page out)** , 스왑 인은 **페이지 인(page in)** 이라 부르기도 한다.
- 이는 다르게 말하면 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다.
  - 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.
  - 이과 같은 방법으로 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.

### 페이지 테이블
- 페이지에 있어 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수 없다는 문제점이 있다.
  - 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 떄문이다.
  - 즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어려워진다.
- 이를 해결하기 위해 페이지 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라고 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 **페이지 테이블(page table)** 을 이용한다.
- **페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표** 이다.
  - CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다.
  - 다시 말해 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.
- 프로세스마다 각자의 프로세스 테이블이 있다.
  - 가령 프로세스 A의 페이지 테이블이 아래와 같다면 CPU는 이를 보고 '0번 페이지는 3번 프레임에, 1번 페이지는 5번 프레임에, 2번 페이지는 2번 프레임에 할당되어 있다.'라는 사실을 알 수 있다.
  - 위와 같은 방식으로 비록 물리 주소상에서는 프로세스들이 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보일 수 있다.
  - 즉, 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행하면 된다.

> #### 여기서 잠깐) 내부 단편화
> - 페이징은 외부 단편화 문제를 해결할 수 있지만, **내부 단편화(internal fragmentation)** 라는 문제를 야기할 수 있다.
>   - 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자른다고 했다.
>   - 그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다.
>   - 다시 말해 모든 프로세스 크기가 페이지의 배수는 아니다.
>   - 가령 페이지 크기가 10KB인데, 프로세스의 크기가 108KB라고 해보자.
>     - 이 경우 마지막 페이지는 2KB만큼의 크기가 남는다.
>     - 이러한 메모리 낭비를 내부 단편화라 한다.
> - 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생한다.
>   - 그렇기에 하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것으로 기대할 수 있다.
>   - 하지만 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간은 낭비가 된다.
>   - **그렇기에 내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요하다.**
>   - 참고로 리눅스의 경우 아래와 같이 간단한 명령으로 페이지 크기를 알아낼 수 있다.
>     - [root@localhost ~] # getconf PAGESIZE
>     - 4096
> - 참고로 리눅스를 포함한 일부 운영체제에서는 위와 같이 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지도 일부 허용하며 메모리를 유지하는 경우도 있다.
>   - 기본적으로 설정된 페이지보다 큰 페이지를 대형 페이지(huge page)라고 한다.
- 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다.
  - 그리고 CPU 내의 **페이지 테이블 베이스 레지스터(PTBR: Page Table Base Register)** 는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.
  - 그렇지만 이렇게 페이지 테이블을 메모리에 두면 문제가 있다.
    - 메모리 접근 시간이 두 배로 늘어난다는 점이다.
    - 메모리에 있는 페이지 테이블을 보기 위해 한 번, 그렇게 알게 된 프레임에 접근하기 위해 한 번, 이렇게 총 두 번의 메모리 접근이 필요하기 때문이다.
      - **이와 같은 문제를 해결하기 위해 CPU 곁에 (일반적으로 MMU 내에) **TLB(Translation Lookaside Buffer)** 라는 페이지 테이블의 캐시 메모리를 둔다.**
        - 우리가 사용하는 컴퓨터의 CPU 곁에는 TLB가 있다.
        - TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다.
        - 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와서 저장한다.
      - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 **TLB 히트(TLB hit)**라고 한다.
        - 이 경우에는 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다.
        - 그렇기에 메모리에 접근을 한 번만 하게 된다.
        - 하지만 만일 페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수 밖에 없다. 이를 **TLB 미스(TLB miss)** 라고 한다.

### 페이징에서의 주소 변환
- 하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있다.
  - 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요하다.
    1. 어떤 페이지 혹은 프레임에 접근하고 싶은지
    2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 그렇기에 페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지 번호(page number)와 변위(offset)** 로 이루어져 있다.
  - 가령 CPU가 32비트 주소를 내보냈다면 이 중 N비트는 페이지 번호, 32-N비트는 변위이다.
- 페이지 번호는 말 그대로 접근하고자 하는 페이지 번호이다.
  - 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지 알 수 있다.
  - 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지 알기 위한 정보이다.
  - 즉, 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환된다.

### 페이지 테이블 엔트리
- 페이지 테이블의 각 엔트리, 다시 말해 페이지 테이블의 각각의 행들은 **페이지 테이블 엔트리(PTE: Page Table Entry)** 라고 한다.
  - 지금까지는 페이지 테이블 엔트리에 담기는 정보로 페이지 번호, 프레임 번호만을 설명했지만, 실은 페이지 테이블 엔트리에는 이외에도 다른 중요한 정보들이 있다.
    - 대표적인 것이 유효 비트, 보호 비트, 참조 비트, 수정 비트이다.

#### 유효 비트
- **유효 비트(valid bit)** 는 현재 해당 페이지에 접근 가능한지 여부를 알려준다.
  - 페이지 테이블 엔트리에서 프레임 번호 다음으로 중요한 정보라고도 볼 수 있다.
  - 페이징에서도 스와핑을 사용할 수 있다고 했었지만 일반적으로 프로세스를 이루는 모든 페이지가 메모리에 있지 않다.
  - 일부 페이지는 보조기억장치(스왑 영역)에 있는 경우가 많다.
  - 유효 비트는 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려주는 비트이다.
  - 즉, 페이지가 메모리에 적재되어 있다면 유효 비트가 1, 페이지가 메모리에 적재되어 있지 않다면 유효 비트가 0이 된다.
- 만일, CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 어떻게 될까?
  - 이 경우 **페이지 폴트(page fault)** 라는 예외(Exception)가 발생한다.
  - CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사하다.
    1. CPU는 기존의 작업 내역을 백업한다.
    2. 페이지 폴트 처리 루틴을 실행한다.
    3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다.
    4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있게 된다.
- **보호 비트(protection bit)** 는 페이지 보호 기능을 위해 존재하는 비트이다.
  - 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다.
  - 가령 비트가 0일 경우 이 페이지는 읽기만 가능한 페이지임을 나타내고, 1일 경우 읽고 쓰기가 모두 가능한 페이지임을 나타내는 것이다.
  - 앞서 프로세스를 이루는 요소 중 코드 영역은 읽기 전용 영역이라고 설명한 것과 같이 이러한 읽기 전용 페이지에 쓰기를 시도하면 운영체제가 이를 막아준다.

---