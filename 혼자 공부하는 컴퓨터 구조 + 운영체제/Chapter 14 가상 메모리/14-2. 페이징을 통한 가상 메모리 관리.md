# Chapter 14 가상 메모리
## 14-2. 페이징을 통한 가상 메모리 관리
- 프로세스를 메모리에 연속적으로 할당하는 방식은 두 가지 문제를 내포하고 있다.
  - 한 가지는 앞선 절에서 다뤘던 외부 단편화이고, 또 하나는 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점이다.
- **가상 메모리(virtual memory)** 는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
  - 이를 가능케 하는 메모리 관리 기법에는 크게 **페이징과 세그멘테티션** 이 있지만, 이 책에서는 운영체제가 사용하는 페이징 기법을 다룬다.
  - 페이징 기법을 이용하면 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만 아니라 앞선 절에서 배운 외부 단편화 문제도 해결할 수 있다.
  
### 페이징이란
- 연속 메모리 할당 방식에서 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다.
- 만일 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로도 할당할 수만 있다면 외부 단편화는 발생하지 않는다.
  - 이것은 **페이징(paging)** 이다.
  - 페이징은 프로세스의 논리 주소 공간을 **페이지(page)** 라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임(frame)** 이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
- 페이징에서도 스와핑을 사용할 수 있다.
  - 페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/스왑 인되는 것이 아닌 페이지 단위로 스왑 아웃/스왑 인된다.
  - 즉, 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃되고, 실행에 필요한 페이지들은 메모리로 스왑 인되는 것이다.
  - 페이징 시스템에서의 스왑 아웃은 **페이지 아웃(page out)** , 스왑 인은 **페이지 인(page in)** 이라 부르기도 한다.
- 이는 다르게 말하면 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다.
  - 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.
  - 이과 같은 방법으로 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.

### 페이지 테이블
- 페이지에 있어 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수 없다는 문제점이 있다.
  - 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 떄문이다.
  - 즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어려워진다.
- 이를 해결하기 위해 페이지 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라고 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 **페이지 테이블(page table)** 을 이용한다.
- **페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표** 이다.
  - CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다.
  - 다시 말해 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.
- 프로세스마다 각자의 프로세스 테이블이 있다.
  - 가령 프로세스 A의 페이지 테이블이 아래와 같다면 CPU는 이를 보고 '0번 페이지는 3번 프레임에, 1번 페이지는 5번 프레임에, 2번 페이지는 2번 프레임에 할당되어 있다.'라는 사실을 알 수 있다.
  - 위와 같은 방식으로 비록 물리 주소상에서는 프로세스들이 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보일 수 있다.
  - 즉, 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행하면 된다.

> #### 여기서 잠깐) 내부 단편화
> - 페이징은 외부 단편화 문제를 해결할 수 있지만, **내부 단편화(internal fragmentation)** 라는 문제를 야기할 수 있다.
>   - 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자른다고 했다.
>   - 그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다.
>   - 다시 말해 모든 프로세스 크기가 페이지의 배수는 아니다.
>   - 가령 페이지 크기가 10KB인데, 프로세스의 크기가 108KB라고 해보자.
>     - 이 경우 마지막 페이지는 2KB만큼의 크기가 남는다.
>     - 이러한 메모리 낭비를 내부 단편화라 한다.
> - 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생한다.
>   - 그렇기에 하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것으로 기대할 수 있다.
>   - 하지만 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간은 낭비가 된다.
>   - **그렇기에 내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요하다.**
>   - 참고로 리눅스의 경우 아래와 같이 간단한 명령으로 페이지 크기를 알아낼 수 있다.
>     - [root@localhost ~] # getconf PAGESIZE
>     - 4096
> - 참고로 리눅스를 포함한 일부 운영체제에서는 위와 같이 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지도 일부 허용하며 메모리를 유지하는 경우도 있다.
>   - 기본적으로 설정된 페이지보다 큰 페이지를 대형 페이지(huge page)라고 한다.
- 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다.
  - 그리고 CPU 내의 **페이지 테이블 베이스 레지스터(PTBR: Page Table Base Register)** 는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.
  - 그렇지만 이렇게 페이지 테이블을 메모리에 두면 문제가 있다.
    - 메모리 접근 시간이 두 배로 늘어난다는 점이다.
    - 메모리에 있는 페이지 테이블을 보기 위해 한 번, 그렇게 알게 된 프레임에 접근하기 위해 한 번, 이렇게 총 두 번의 메모리 접근이 필요하기 때문이다.
      - **이와 같은 문제를 해결하기 위해 CPU 곁에 (일반적으로 MMU 내에) **TLB(Translation Lookaside Buffer)** 라는 페이지 테이블의 캐시 메모리를 둔다.**
        - 우리가 사용하는 컴퓨터의 CPU 곁에는 TLB가 있다.
        - TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다.
        - 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와서 저장한다.
      - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 **TLB 히트(TLB hit)**라고 한다.
        - 이 경우에는 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다.
        - 그렇기에 메모리에 접근을 한 번만 하게 된다.
        - 하지만 만일 페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수 밖에 없다. 이를 **TLB 미스(TLB miss)** 라고 한다.

### 페이징에서의 주소 변환
- 하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있다.
  - 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요하다.
    1. 어떤 페이지 혹은 프레임에 접근하고 싶은지
    2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 그렇기에 페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지 번호(page number)와 변위(offset)** 로 이루어져 있다.
  - 가령 CPU가 32비트 주소를 내보냈다면 이 중 N비트는 페이지 번호, 32-N비트는 변위이다.
- 페이지 번호는 말 그대로 접근하고자 하는 페이지 번호이다.
  - 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지 알 수 있다.
  - 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지 알기 위한 정보이다.
  - 즉, 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환된다.

### 페이지 테이블 엔트리
- 페이지 테이블의 각 엔트리, 다시 말해 페이지 테이블의 각각의 행들은 **페이지 테이블 엔트리(PTE: Page Table Entry)** 라고 한다.
  - 지금까지는 페이지 테이블 엔트리에 담기는 정보로 페이지 번호, 프레임 번호만을 설명했지만, 실은 페이지 테이블 엔트리에는 이외에도 다른 중요한 정보들이 있다.
    - 대표적인 것이 유효 비트, 보호 비트, 참조 비트, 수정 비트이다.

#### 유효 비트
- **유효 비트(valid bit)** 는 현재 해당 페이지에 접근 가능한지 여부를 알려준다.
  - 페이지 테이블 엔트리에서 프레임 번호 다음으로 중요한 정보라고도 볼 수 있다.
  - 페이징에서도 스와핑을 사용할 수 있다고 했었지만 일반적으로 프로세스를 이루는 모든 페이지가 메모리에 있지 않다.
  - 일부 페이지는 보조기억장치(스왑 영역)에 있는 경우가 많다.
  - 유효 비트는 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려주는 비트이다.
  - 즉, 페이지가 메모리에 적재되어 있다면 유효 비트가 1, 페이지가 메모리에 적재되어 있지 않다면 유효 비트가 0이 된다.
- 만일, CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 어떻게 될까?
  - 이 경우 **페이지 폴트(page fault)** 라는 예외(Exception)가 발생한다.
  - CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사하다.
    1. CPU는 기존의 작업 내역을 백업한다.
    2. 페이지 폴트 처리 루틴을 실행한다.
    3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다.
    4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있게 된다.
- **보호 비트(protection bit)** 는 페이지 보호 기능을 위해 존재하는 비트이다.
  - 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다.
  - 가령 비트가 0일 경우 이 페이지는 읽기만 가능한 페이지임을 나타내고, 1일 경우 읽고 쓰기가 모두 가능한 페이지임을 나타내는 것이다.
  - 앞서 프로세스를 이루는 요소 중 코드 영역은 읽기 전용 영역이라고 설명한 것과 같이 이러한 읽기 전용 페이지에 쓰기를 시도하면 운영체제가 이를 막아준다.
  - 보호 비트는 세 개의 비트로 좀 더 복잡하게 구현할 수 도 있다.
    - 읽기(Read)를 나타내는 r, 쓰기(Write)를 나타내는 w, 실행(eXecute)를 나타내는 x의 조합으로 읽기, 쓰기, 실행하기 권한의 조합을 나타낼 수 있다.
    - 가령 보호 비트가 100으로 설정된 페이지의 경우 r은 1, w와 x는 0이므로 이 페이지는 읽기만 가능하다. 
- **참조 비트(reference bit)** 는 CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다.
  - 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지는 0으로 유지된다.
- **수정 비트(modified bit)** 는 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려 준다.
  - **더티 비트(dirty bit)** 라고도 부른다.
  - 더티 비트가 1이면 변경된 적이 있는 페이지, 0이면 변경된 적이 없는 페이지(한 번도 접근한 적 없거나 읽기만 했던 페이지)임을 나타낸다.
  - 수정 비트는 왜 존재하는 것일까요?
    - 수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재한다.
  - CPU는 메모리를 읽기도 하지만 메모리에 값을 쓰기도 한다.
    - CPU가 한 번도 접근하지 않았거나 읽기만 한 페이지의 경우 보조기억장치에 저장된 해당 페이지의 내용과 메모리에 저장된 페이지 내용은 아래 그림과 같이 서로 같은 값을 가지고 있다.
    - 이렇게 한 번도 수정된 적이 없는 페이지가 스왑 아웃될 경우 아무런 추가 작업 없이 새로 적재된 페이지로 덮어쓰기만 하면 된다.
      - 어차피 똑같은 페이지가 보조기억장치에 저장되어 있기 때문이다.
    - 하지만 CPU가 쓰기 작업을 수행한 페이지(수정 비트가 1인 페이지)의 경우 보조기억장치에 저장된 페이지의 내용과 메모리에 저장된 페이지의 내용은 서로 다른 값을 갖게 된다.
      - 이렇게 수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가되어야 한다.
      - **이 작업이 필요한 페이지인지 아닌지를 판단하기 위해 페이지 테이블 엔트리에 수정 비트를 두는 것이다.**

> #### 좀 더 알아보기) 페이징의 이점 - 쓰기 시 복사
> - 외부 단편화 문제를 해결한다는 점 이외에도 페이징이 제공하는 이점은 다양하다.
>   - 대표적인 것이 프로세스 간에 페이지를 공유할 수 있다는 점이다.
>   - 프로세스 간 페이지를 공유하는 사례로는 공유 라이브러리 등 다양하지만, 대표적인 예시로 **쓰기 시 복사(copy on write)** 가 있다.
> - 유닉스나 리눅스와 같은 운영체제에서 fork 시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세스로서 만들어진다.
>   - '프로세스 간에는 기본적으로 자원을 공유하지 않는다.'는 프로세스의 전통적인 개념에 입각하면 새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 전혀 다른 메모리 공간에 생성된다.
>   - 한 마디로 부모 프로세스의 메모리 영역이 다른 영역에 자식 프로세스로서 복제되고, 각 프로세스의 페이지 테이블은 자신의 고유한 페이지가 할당된 프레임을 가리킨다.
>   - 하지만 이 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기한다.
> - 반면, 쓰기 시 복사에서는 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다.
>   - 이로써 굳이 부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리킬 수 있다.
>   - 만일 부모 프로세스와 자식 프로세스가 메모리에 어떠한 데이터도 쓰지 않고 그저 읽기 작업만 이어 나간다면 이 상태가 지속된다.
>   - 그렇지만 프로세스 간에는 자원을 공유하지 않는다고 했다!!!
>     - 부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제된다.
>     - 각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리킨다.
>       - 이것이 **쓰기 시 복사** 이다.
>       - 이러한 쓰기 시 복사를 통해 프로세스 생선 시간을 줄이는 것은 물론 메모리 공간 절약도 가능하.

> #### 좀 더 알아보기) 계층적 페이징
> - 페이지 테이블의 크기는 생각보다 작지 않다.
>   - 프로세스의 크기가 커지면 자연히 프로세스 테이블의 크기도 커지기 때문에 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비이다.
>   - 이에 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이 등장했는데, 이것이 **계층적 페이징(hierarchical paging)** 이다.
> - 계층적 페이징은 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식이다.
>   - 여러 단계의 페이지를 둔다는 점에서 **다단계 페이지 테이블(multilevel page table)** 기법이라고 부른다.
>   - 프로세스의 페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식이다.
> - 페이지 테이블을 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다.
>   - 페이지 테이블들 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때가 있으면 그때 메모리에 적재하면 그만이다.
> - 계층적 페이징을 사용하는 경우 CPU가 발생하는 논리 주소도 달라진다.
>   - **바깥 페이지 번호** 에 해당하는 항목은 CPU와 근접한 곳에 위치한(바깥에 위치한) 페이지 테이블 엔트리를 가리키고, **안쪽 페이지 번호** 는 첫 번쨰 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킨다.
>   - | 바깥 페이지 번호 | 안쪽 페이지 번호 | 변위 |
> - 이러한 논리 주소를 토대로 주소 변환은 다음과 같이 이루어진다.
>   1. 바깥 페이지 번호를 통해 **페이지 테이블의 페이지** 찾기
>   2. **페이지 테이블의 페이지** 를 통해 **프레임 번호** 를 찾고 변위를 더함으로서 물리 주소 얻기
> - **페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아지므로 계층이 많다고 해서 반드시 좋다고 볼 수는 없다.**

---