# Chapter 06. 메모리와 캐시 메모리
## 6-3. 캐시 메모리
- CPU는 프로그램을 실행하는 과정에서 메모리에 저장된 데이터를 빈번하게 사용한다.
- 하지만 CPU가 메모리에 접근하는 시간은 CPU의 연산 속도보다 느리다.
- CPU가 연산을 빨리 한다 해도 메모리에 접근하는 시간이 느리면 CPU의 빠른 연산 속도는 의미가 없어지는데 이를 극복하기 위한 장치가 **캐시 메모리** 이다.

### 저장 장치 계층 구조
- 저장 장치는 일반적으로 아래와 같은 명제를 따른다.
  1. CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.
  2. 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다.
- CPU 내의 레지스터, 메모리(RAM), USB 메모리를 비교해보자
  - CPU와 가장 가까운 레지스터는 일반적으로 RAM보다 용량이 작지만, 접근 시간이 압도적으로 빠르고 가격이 비싸다.
  - 그리고 USB 메모리보다 CPU에 더 가까운 RAM은 접근 시간이 훨씬 더 빠르지만, 같은 용량이라 할지라도 가격은 더 비싸다.
  - 즉, 낮은 가격대의 대용량 저장 장치를 원한다면 느린 속도는 감수해야하고, 빠른 메모리를 원한다면 작은 용량과 비싼 가격은 감수해야 한다.
- **저장 장치 계층 구조(memory hierarchy)**
  - 컴퓨터가 사용하는 저장 장치들은 '**CPU** 에 얼마나 가까운가'를 기준으로 계층적으로 나타낼 수 있는 것

### 캐시 메모리
- CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 느리다.
  - 그럼에도 불구하고 CPU는 프로그램을 실행하는 과정에서 메모리에 빈번히 접근해야 한다.
  - CPU 연산 속도가 아무리 빨라도 메모리 접근 속도가 따라가지 못하면 아무 소용이 없다.
- 그래서 등장한 저장 장치가 **캐시 메모리** 이다.
- **캐시 메모리(cache memory)** 는 CPU와 메모리 사이에 위치하고, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치이다.
  - 캐시 메모리는 CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 탄생했다.
  - CPU가 매번 메모리에 왔다 갔다 하는 것은 시간이 오래 걸리다보니 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가져 와서 활용하는 구조이다.
- 컴퓨터 내부에는 여러 개의 캐시 메모리가 있다.
  - 이 캐시 메모리들은 CPU(코어)와 가까운 순서대로 계층을 구성한다.
  - 코어와 가장 가까운 캐시 메모리를 **L1(level 1) 캐시**, 그다음 가까운 캐시 메모리를 **L2(level 2) 캐시**, 그다음 캐시메모리를 **L3(level 3) 캐시** 라고 한다.
    - 캐시 메모리의 용량은 L1, L2, L3 순으로 커지고, 속도는 L3, L2, L1 순으로 빨라진다.
    - 일반적으로 가격은 L3, L2, L1 순으로 비싸진다.
  - CPU가 메모리 내에 데이터가 필요하다고 판단하면 우선 L1 캐시에 해당 데이터가 있는지 확인하고, 없다면 L2, L3 캐시 순으로 데이터를 검색한다.
  - **분리형 캐시(split cache)**
    - 코어와 가장 가까운 L1 캐시는 조금이라도 접근 속도를 빠르게 만들기 위해 명령어 만을 저장하는 L1 캐시인 L1I 캐시와 데이터만을 저장하는 L1 캐시인 L1D 캐시로 분리하는 경우가 있다.

### 참조 지역성 원리
- 캐시 메모리는 메모리보다 용량이 작다.
- 당연하게도 캐시 메모리는 메모리에 있는 모든 내용을 가져다 저장할 수 없다.
- 메모리가 보조기억장치의 일부를 복사하여 저장하는 것처럼 캐시 메모리는 메모리의 일부를 복사하여 저장한다.
- 그렇다면 캐시 메모리는 무엇을 저장해야 할까?
  - 보조기억장치는 전원이 꺼져도 기억할 대상을 저장하고, 메모리는 실행중인 대상을 저장한다면 캐시 메모리는 CPU가 사용할 법한 대상을 예측하여 저장한다.
  - 이때 자주 사용될 것으로 예측한 데이터가 실제로 들어맞아 캐시 메모리 내 데이터가 CPU에서 활용될 경우 **캐시 히트(cache hit)** 라고 한다.
  - 반대로 자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만, 예측이 틀려 메모리에서 필요한 데이터를 직접 가져와야 하는 경우를 **캐시 미스(cache miss)** 라고 한다.
    - 캐시 미스가 발생하면 CPU가 필요한 데이터를 메모리에서 직접 가져와야 하기 때문에 캐시 메모리의 이점을 활용할 수 없다.
- **캐시 적중률(cache hit ratio)** 계산식
  - > 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
- 일반적인 컴퓨터의 캐시 적중률은 85~95% 이상이다.
- 캐시 메모리의 이점을 제데로 활용하려면 CPU가 사용할 법한 데이터를 제대로 예측해서 캐시 적중률을 높여야 한다.
  - 캐시 메모리는 한 가지 원칙을 따라 메모리로부터 가져올 데이터를 결정한다.
    - 바로 **참조 지역성의 원리(locality of reference, principle of locality)**이다.

#### 참조 지역성 원리(locality of reference, principle of locality)
- CPU가 메모리에 접근할 때의 주된 경향을 바탕을 만들어진 원리이다.
> 1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
> 2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

#### 첫째, '최근에 접근했던 메모리 공간에 다시 접근하려는 경향'은 무엇일까요? 
- 'CPU는 변수가 저장된 메모리 공간을 언제든 다시 참조할 수 있다'는 것을 의미한다.
- 그리고 변수에 저장된 값은 일반적으로 한 번만 사용되지 않고 프로그램이 실행되는 동안 여러 번 사용된다.
- 즉, CPU는 최근에 접근했던 (변수가 저장된) 메모리 공간을 여러 번 다시 접근할 수 있다.
- **시간 지역성(temporal locality)**
  - '최근에 접근했던 메모리 공간에 다시 접근하려는 경향'

#### 둘째, '접근한 메모리 공간 근처를 접근하려는 경향'은 무엇일까요?
- CPU가 실행하려는 프로그램은 보통 관련 데이터들끼리 한데 모여 있다.
  - 가령 메모리 내에 워드프로세서 프로그램, 웹 브라우저 프로그램, 게임 프로그램이 있다고 가정해보자
  - 이 세 프로그램은 서로 관련 있는 데이터끼리 모여서 저장된다.
    - 워드 프로세서 프로그램은 워드 프로세서 관련 데이터들이 모여 저장되고, 웹 브라우저 프로그램은 웹 브라우저 관련 데이터들이 모여 저장되고, 게임 프로그램은 게임 관련 데이터들이 모여 저장된다.
  - 그리고 하나의 프로그램 내에서도 관련 있는 데이터들은 모여서 저장된다.
    - 가령 워드 프로세서 프로그램에 자동 저장 기능, 입력 기능, 출력 기능이 있다고 했을 때 각각의 기능과 관련한 데이터는 모여 저장된다.
- CPU가 워드 프로세서 프로그램을 실행할 적에는 워드 프로세서 프로그램이 모여 있는 공간 근처를 집중적으로 접근할 것이다.
  - 이렇게 '접근한 메모리 공간 근처를 접근하려는 경향'을 **공간 지역성(spatial locality)** 라고 한다.

---
