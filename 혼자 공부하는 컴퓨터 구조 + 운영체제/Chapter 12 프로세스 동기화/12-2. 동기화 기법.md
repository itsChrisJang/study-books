# Chapter 12 프로세스 동기화
## 12-2. 동기화 기법
- 어떻게 해야 임계 구역에 오직 하나의 프로세스만 진입하게 하고, 올바른 실행 순서를 보장할 수 있을까?
  - 이를 위해 동기화를 위한 대표적인 도구인 **뮤텍스 락, 세마포, 모니터** 를 공부해보자.

### 뮤텍스 락
- 임계 구역 문제와 이를 해결하기 위한 동기화를 옷 가게의 탈의실에 비유해보자.
  - 탈의실에는 한 명의 인원만 들어갈 수 있다.
  - 손님은 '프로세스', 탈의실은 '임계 구역'이라 할 수 있다.
  - 탈의실에는 자물쇠가 있어서 자물쇠가 걸려 있는 유무에 따라서 탈의실을 이용한다.
- 이 자물쇠 기능을 코드로 구현한 것이 **뮤텍스 락(mutex lock: MUTual EXclusion lock)** 이다.
  - 뮤텍스 락은 동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 만드는 도구, 즉 상보 배제를 위한 동기화 도구이다.
- 임계 구역에 진입하는 프로세스는 '내가 지금 임계 구역에 있음'을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고, 다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있다.
- 뮤텍스 락의 매우 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현할 수 있다.
  - 자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock
  - 임계 구역을 잠그는 역할: acquire 함수
    - 프로세스가 임계 구역에 진입하기 전에 호출하는 함수이다.
    - 만일 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고, 임계 구역이 열려 있다면 임계 구역을 잠그는(lock을 true로 바꾸는) 함수이다.
  - 임계 구역의 잠금을 해제하는 역할: release 함수
    - 임계 구역에서의 작업이 끝나고 호출하는 함수이다.
    - 현재 잠긴 임계 구역을 열어주는(lock을 false로 바꾸는) 함수라고 보면 된다.
  - acquire와 release 함수를 임계 구역 전후로 호출함으로써 하나의 프로세스만 임계 구역에 진입할 수 있다.
- 뮤텍스 락을 구현함으로써
  - 락을 흭득할 수 없다면 무작정 기다리고,
  - 락을 흭득할 수 있다면 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행하고,
  - 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써
- 임계 구역을 보호할 수 있다.
- 참고로 acquire 함수를 보면 임계 구역이 잠겨 있을 경우 프로세스는 반복적으로 lock을 확인한다.
  - 이는 마치 탈의실 문이 잠겨 있는지 쉴 새 없이 반복하며 확인하는 것과 같다.
  - 이런 대기 방식을 **바쁜 대기(busy wait)** 라고 한다.
  
### 세마포
- **세마포(semaphore)** 는 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구이다.
- 뮤텍스 락은 하나의 공유 자원에 접근하는 프로세스를 상정한 방식이다.
  - 즉, 탈의실이 하나 있는 경우를 가정하고 만든 동기화 도구이다.
  - 하지만 탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우(각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 한다.
- 예를 들어 옷가게에 탈의실이 세 개 있고 한 번에 하나의 프로세스만 이용할 수 있는 프린터 세 대가 있는 상황을 가정하자
  - 하나의 프린터를 사용할 수 있는 프로세스는 하나이지만, 총 세 개의 프로세스가 공유 자원(세 대의 프린터)을 이용할 수 있다.
- 세마포는 철도 신호기에서 유래된 단어이다.
  - 기차는 신호기가 내려가 있을 때는 '멈춤' 신호로 간주하고 잠시 멈춘다.
  - 반대로 신호기가 올라와 있을 때는 '가도 좋다'는 신호로 간주하고 다시 움직이기 시작한다.
  - 세마포는 이와 같이 '멈춤' 신호와 '가도 좋다'는 싢로서 임계 구역을 관리한다.
  - 즉, 프로세스는 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리고, 가도 좋다는 신호를 받으면 그제서야 임계 구역에 들어가게 된다.
- 세마포가 어떻게 구현되는지 간략하게 알아보자.
  - 세마포는 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현할 수 있다.
    - 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 **전역 변수 S**
    - 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 **wait 함수**
    - 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 **signal 함수**

> #### 세마포 변수와 함수 이름
> - 일부 전공서에서는 세마포를 처음 개발한 네덜란드의 컴퓨터과학자 에츠허르 다익스트라의 모국어에 근거해 wait와 signal 함수를 P,V 로 명명하기도 하고, 일부 전공서에서는 철도 신호기에 근거해 down, up으로 명명하기도 한다.
> - 다만 변수와 함수를 어떻게 지칭하든 원리와 작동 방식은 모두 동일하다.

- 뮤텍스 락을 사용할 때 임계 구역 진입 전후로 acquire()와 release()를 호출했듯이 세마포도 임계 구역 진입 전후로 wait()와 signal()을 호출한다.
- 세마포에서 wait 함수는 만일 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 PCB를 세마포를 위한 대기 큐에 집어 넣는다.
  - 그리고 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면 signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨 준다.
- 세마포의 간단한 작동 순서
```text
wait() {
    S--;
    if ( S < 0 ) {
        add this process to Queue;  /* 1 */
        sleep();                    /* 2 */
    }
}
```
1. 해당 프로세스 PCB를 대기 큐에 삽입한다.
2. 대시 상태로 접어든다.
```text
signal() {
    S++;
    if ( S <= 0 ) {
        remove a process p from Queue;  /* 1 */
        wakeup(p);                      /* 2 */
    }
}
```
1. 대기 큐에 있는 프로세스 p를 제거한다.
2. 프로세스 p를 대기 상태에서 준비 상태로 만든다.

------
- 지난 절에서 동기화의 정의에 대해 설명했을 때 '동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 제어하는 것'도 **동기화(상호 배제를 위한 동기화)** 이지만, '특정 조건이 만족되어야만 실행할 수 있는 상황에서 올바른 순서대로 실행하게 하는것' 또한 **동기화(실행 순서 제어를 위한 동기화)** 라고 했다.
- 지금까지 세마포를 이용한 상호 배제를 위한 동기화 방법이었다면 이번에는 세마포를 이용해 프로세스의 순서를 제어하는 방법에 대해 알아보자.
  - 세마포를 이용하면 동시에 실행되는 프로세스의 실행 순서도 제어할 수 있다.
  - 방법은 간단하다. 
  - 세마포의 변수 S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.

| P1       | P2       |
|----------|----------|
|          | wait()   |
| // 임계 구역 | // 임계 구역 |
| signal() ||
- 이 경우, P1이 먼저 실행되면 P1이 임계 구역에 먼저 진입하는 것은 자명한 일이고, P2가 먼저 실행되더라도 P2는 wait 함수를 만나므로 P1이 임계 구역에 진입하게 된다.
- 그리고 P1이 임계 구역의 실행을 끝내고 signal을 호출하면 그제서야 P2가 임계 구역에 진잉ㅂ한다.
- 즉, P1이 먼저 실행되든 P2가 먼저 실행되는 반드시 P1, P2 순서대로 실행된다.

### 모니터
- 세마포는 그 자체로 매우 훌륭한 프로세스 동기화 도구이지만, 사용하기가 불편하다.
  - 매번 임계 구역에 앞뒤로 일일이 wait와 signal 함수를 명시하는 것은 번거로운 일이기 때문이다.
  - 더군다나 잘못된 코드(세마포를 누락한 경우, wait와 signal 순서를 헷갈린 경우, wait와 signal을 중복해서 사용한 경우)로 인해 예기치 못한 결과를 얻을 수 있다.
- 이에 최근에 등장한 동기화 도구가 **모니터(monitor)** 이다.
  - 모니터는 세마포에 비하면 사용자가 사용하기에 훨씬 편리한 도구이다.
  - 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)로 묶어 관리한다.
  - 그리고 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 한다.
- 이를 위해 모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 한다.
  - 즉, 모니터는 공유 자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공한다.
- 이 밖에도 모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공한다.
  - 특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 모니터는 **조건 변수(condition variable)** 를 사용하는데 조건 변수는 프로세스나 스레드의 시행 순서를 제어하기 위해 사용하는 특별한 변수이다.
- 조건 변수로는 wait와 signal 연산을 수행할 수 있다.
  - 우선 wait는 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산이다.
  - 여기서 헷갈리면 안 되는 점은 모니터에 진입하기 위해 삽입되는 큐(상호 배제를 위한 큐)와 wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐(조건 변수에 대한 큐)는 다르다는 점이다.
    - 전자는 모니터에 한 번에 하나의 프로세스만 진입하도록 하기 위해 만들어진 큐이고, 후자는 모니터에 이미 진입한 프로세스의 실행 조건이 만족될 때까지 잠시 실행이 중단되어 기다리기 위해 만들어진 큐이다.
---