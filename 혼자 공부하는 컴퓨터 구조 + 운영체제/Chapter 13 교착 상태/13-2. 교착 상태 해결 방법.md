# Chapter 13 교착 상태
## 13-2. 교착 상태 해결 방법
- 운영체제가 교착 상태를 해결하는 방법에는 크게 세 가지가 있다.
  - 예방, 회피, 검출 후 회복이다.
- 운영체제는 애초에 교착 상태가 일어나지 않도록 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착 상태를 **예방** 할 수 있고, 교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식으로 교착 상태를 **회피** 할 수 도 있다.
  - 그리고 자원을 제약 없이 할당하다가 교착 상태가 **검출** 되면 교착 상태를 **회복** 하는 방법을 취할 수도 있다.

### 교착 상태 예방
- **교착 상태를 예방** 하는 방법은 교착 상태 필요 조건 네 가지 중 하나를 충족하지 못하게 하는 방법과 같다.
  - 즉, 프로세스들에 자원을 할당할 때 상호 배제, 점유와 대기, 비선점, 원형 대기 중 하나의 조건이라도 만족시키지 않게 할당하면 교착 상태는 발생하지 않는다.

#### 우선 자원의 상호 배제를 없애 볼까요?
- 자원의 상호 배제를 없앤다는 말의 의미는 모든 자원을 공유 가능하게 만든다는 말과 같다.
  - 다만 이 방식대로면 이론적으로 교착 상태를 없앨 수 있지만, 현실적으로 모든 자원의 상호 배제를 없애기는 어렵기에 해당 방식은 현실에서 사용하기에는 무리가 있다.

#### 그렇다면 점유와 대기를 없애 봅시다.
- 이는 마치 식사하는 철학자 문제 속 철학자들로 하여금 한 손에 포크를 들고 다른 포크를 기다리지 못하게 금지하는 것과 같다.
  - 포크를 두 개 동시에 들게 하거나, 아니면 아예 들지 못하게 하는 것이다.
  - 점유와 대기를 없애면 운영체제는 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분한다.
- 이 방식도 이론적으로 교착 상태를 해결할 수 있지만 단점이 존재한다.
  - 우선 자원의 활용률이 낮아질 우려가 있다.
  - 점유와 대기를 금지하면 한 프로세스에 필요한 자원들을 몰아주고, 그 다음에 다른 프로세스에 필요한 자원들을 몰아줘야 한다.
    - 이는 당장 자원이 필요해도 기다릴 수밖에 없는 프로세스와 사용되지 않으면서 오랫동안 할당되는 자원을 다수 양산하기 때문에 자원의 활용률이 낮아진다.
- 게다가 점유와 대기를 금지하면 많은 자원을 사용하는 프로세스가 불리해진다.
  - 자원을 많이 사용하는 프로세스는 자원을 적게 사용하는 프로세스에 비해 동시에 자원을 사용할 타이밍을 확보하기가 어렵기 때문이다.
  - 이는 결국 많은 자원을 필요로 하는 프로세스가 무한정 기다리게 되는 기아 현상을 야기할 우려가 있다.

#### 이번에는 비선점 조건을 없애 보겠습니다.
- 비선점 조건을 없애면 자원을 이용 중인 프로세스로부터 해당 자원을 빼앗을 수 있다.
  - 식사하는 철학자 문제에서 철학자의 포크를 빼앗을 수만 있다면 교착 상태는 발생하지 않듯 자원의 비선점 조건을 없애면 교착 상태는 발생하지 않는다.
- 이 방식은 선점하여 사용할 수 있는 일부 자원에 대해서는 효과적이다.
  - 가령 CPU는 프로세스들이 선점할 수 있는 대표적인 자원이다.
  - 한 프로세스가 CPU를 이용하다가 일정 시간이 지나면 아직 작업이 모두 끝나지 않았다고 할지라도 다른 프로세스가 CPU를 할당받아 사용할 수 있기 때문이다.
- 하지만 모든 자원이 이렇게 선점 가능한 것은 아니다.
  - 한 프로세스의 작업이 끝날 때까지 다른 프로세스가 기다려야 하는 자원도 얼마든지 있다.
  - 예를 들어 한 번에 하나의 프로세스만 이용 가능한 프린터 자원이 있다고 생각해보자.
    - 한 프로세스가 이 프린터를 이용하는 도중에 다른 프로세스가 프린터 자원을 빼앗어 사용하기가 어렵겠죠?
  - 그렇기에 비선점 조건을 없애 모든 자원을 빼앗을 수 있도록 하여 교착 상태를 예방하는 방법은 다소 범용성이 떨어지는 방안이다.

#### 마지막으로 원형 대기 조건을 없애 봅시다.
- 원형 대기를 없애는 방법은 간단하다.
  - 모든 자원에 번호를 붙이고, 오름차순으로 차원을 할당하면 원형 대기는 발생하지 않는다.
- 예를 들어, 식사하는 철학자 문제에서 모든 포크에 1번부터 5번까지 번호를 붙이고, 철학자들로 하여금 번호가 낮은 포크에서 높은 포크 순으로 집어들게 한다면 원형대기는 발생하지 않는다.
  - 5번 포크를 집어들고 1번 포크를 집어들 수 없기 때문이다.
  - 이는 마치 철학자들이 원형 식탁이 아닌 사각형 식탁에서 일렬로 앉아 식사하는 상황과 유사하다.
  - 이 경우 철학자들이 동시에 포크를 들어도 문제될 것이 없다.
- 원형 대기를 없앰으로써 교착 상태를 예방하는 방식은 앞선 세 방식에 비하면 비교적 현실적이고 실용적인 방식이지만, 역시 단점이 있다.
  - 모든 컴퓨터 시스템 내에 존재하는 수만은 자원에 번호를 붙이는 일은 그리 간단한 작업이 아니거니와 각 자원에 어떤 번호를 붙이는지에 따라 특성 자원의 활용률이 떨어질 수 있다.

### 교착 상태 회피
- **교착 상태 회피** 는 교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식이다.
  - 교착 상태 회피 방식에서는 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주한다.
- 프로세스들에 할당할 수 있는 자원이 충분한 상황에서 프로세스들이 한두 개의 적은 자원마을 요구한다면 교착 상태는 발생하지 않는다.
  - 반면 프로세스들에 할당할 수 있는 자원이 한정된 상황에서 모든 프로세스들이 한 번에 많은 자원을 요구하면 교착 상태가 발생할 위험이 증가한다.
- 식사하는 철학자 문제를 생각해보자.
  - 포크가 100개, 1,000개 있는 상태에서 철학자들이 한두 개의 포크를 요구하면 교착 상태를 발생하지 않는다.
  - 반면, 포크의 양이 충분하지 않은 상태에서 철학자들이 모두 자신이 요구할 수 있는 최대의 포크(두 개)를 요구하면 교착상태가 발생한다.
  - 그렇기 때문에 프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법이 교착 상태 회피이다.
- 교착 상태를 회피하는 방법을 학습하기 위해서는 안정 상태와 불안정 상태, 그리고 안전 순서열이라는 용어를 알아야 한다.
  - 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태를 **안전 상태(safe state)** 라고 부르고, 교착 상태가 발생할 수 있는 상황을 **불안정 상태(unsafe state)** 라고 부른다.
- **안전 순서열(safe sequence)** 은 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미한다.
  - 예를 들어 웹 브라우저, 메모장, 게임 프로세스가 동시에 운영체제에 자원을 요청한 상황에서 웹 브라우저-메모장-게임 프로세스 순서대로 자원을 할당하면 교착 상태가 발생하지 않는다고 가정해보자.
    - 이 경우 웹 브라우저 -> 메모장 -> 게임이 안전 순서열이 된다.
    - 안전 순서열이 있는 상태를 안전 상태라고 볼 수 있다.
    - 이렇게 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 안전 순서열이라고 하고 안전 순서열대로 프로세스들에 자우너을 배분하여 교착 상태가 발생하지 않는 상태를 **안전 상태** 라고 한다.
    - 반면, **불안전 상태** 는 안전 순서열이 없는 상황이다.
      - 시스템이 불안전 상태에 놓이면 교착 상태가 발생할 수 있는 위험이 있다.
- 즉, 운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당하면 된다.
  - 즉, 교착 상태 회피 방식은 항시 안전 상태를 유지하도록 자원을 할당하는 방식이라 보면 된다.

### 교착 상태 검출 후 회복
- 교착 상태 예방과 회피는 교착 상태 발생을 막기 위한 노력이었다면, **교착 상태 검출 후 회복** 은 교착 상태 발생을 인정하고 사후에 조치하는 방식이다.
- 검출 후 회복 방식에서 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사한다.
  - 그리고 교착 상태가 검출되면 그때 비로소 다음과 같은 방식으로 회복한다.

#### 선점을 통한 회복
- 선점을 통한 회복은 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식이다.
  - 교착 상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식이다.

#### 프로세스 강제 종료를 통한 회복
- 프로세스 강제 종료를 통한 회복은 가장 단순하면서 확실한 방식이다.
  - 운영체제는 교착 상태에 놓인 프로세스를 강제 종료할 수도 있고, 교착 상태가 없애질 때까지 한 프로세스씩 강제 종료할 수도 있다.
    - 전자는 한 방에 교착 상태를 해결할 수 있는 가장 확실한 방식이지만 그만큼 많은 프로세스들이 작업 내역을 잃게 될 가능성이 있고, 후자는 작업 내역을 잃는 프로세스는 최대한 줄일 수 있지만 교착 상태가 없어졌는지 여부를 확인하는 과정에서 오버헤드를 야기한다.
    
#### 타조 알고리즘(ostrich algorithm)
- 드물게 발생하는 잠재적 문제를 무시로 대처하는 방식
- 완벽을 추구하는 과학자나 수학자 입장에서는 납득할 수 없는 방식일지 모르나, 문제 발생의 빈도나 심각성에 따라 최대 효율을 추구하는 엔지니어 입장에서는 때떄로 이 방식이 적합할 때도 많다.

---