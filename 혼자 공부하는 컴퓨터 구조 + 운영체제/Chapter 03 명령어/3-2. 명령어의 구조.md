# Chapter 03. 명령어
## 3-2. 명령어의 구조
### 연산 코드와 오퍼랜드
- 명령어
  - 연산 코드와 오퍼랜드로 구성되어 있음
  - **연산 코드(operation code)(= 연산자)**
    - '명령어가 수행할 연산'
    - **기본적인 연산 코드 유형**
      1. 데이터 전송
      2. 산술/논리 연산
      3. 제어 흐름 변경
      4. 입출력 제어
    - **연산 코드 필드**
      - 연산 코드가 담기는 영역
  - **오퍼랜드(operand)(= 피연산자)**
    - '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'
    - **오퍼랜드 필드(= 주소 필드)**
      - 오퍼랜드가 담기는 영역
      - 숫자와 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.
      - **0-주소 명령어**
        - 오퍼랜드가 하나도 없는 명령어
      - **1-주소 명령어**
        - 오퍼랜드가 하나인 명령어
      - **2-주소 명령어**
        - 오퍼랜드가 두 개인 명령어
      - **3-주소 명령어**
        - 오퍼랜드가 세 개인 명령어

### 주소 지정 방식
- **주소 지정 방식(addressing mode)**
  - 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
  - 즉, 유효 주소를 찾는 방법
- Q : "왜 오퍼랜드 필드에 메모리나 레저스터의 주소를 담는 것일까?"
- A : 명령어의 길이 때문이다.
  - 하나의 명령어가 n비트로 구성되어 있고, 그중 연산 코드 필드가 m비트라고 가정한다면 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m비트가 된다.
  - 2-주소 명령어, 3-주소 명령어라면 오버랜드 필드의 크기는 더욱 작아진다.
  - **하지만 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.**
  - **유효 주소(effective address)**
    - 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치

#### 즉시 주소 지정 방식(immediate addressing mode)
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다.
- 장점
  - 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 주소 지정 방식들보다 빠르다.
- 단점
  - 표현할 수 있는 데이터의 크기가 작아진다.

#### 직접 주소 지정 방식(direct addressing mode)
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식이다.
- 장점
  - 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 크다.
- 단점
  - 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어든다.
  - 즉, 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

#### 간접 주소 지정 방식(indirect addressing mode)
- 유효 주소의 주소를 오퍼랜드 필드에 명시한다.
- 장점
  - 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어진다.
- 단점
  - 하지만 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식들보다 일반적으로 느린 방식이다.

#### 레지스터 주소 지정 방식(register addressing mode)
- 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법이다.
- 일반적으로 CPU 외부에 있는 메모리제 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다.
- 그러므로 레저스터 주소 지정 방식은 직접 주소 지정 방식 보다 빠르게 데이터에 접근할 수 있따.
- 다만, 레저스터 주소 지정 방식은 직접 주소 지정 방식과 비슷한 문제를 공유한다.
  - 표현할 수 있는 레저스터 크기에 제한이 생길 수 있다는 점이다.

#### 레지스터 간접 주소 지정 방식(register indirect addressing mode)
- 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다.
- 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 차이이자 장점이 있다.
- 메모리에 접근하는 것이 레지스터에 접근하는 것보다 더 느리기 때문에 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠르다.

#### 주소 지정 방식 정리
- **주소 지정 방식**
  - 연산에 사용할 데이터를 찾는 방법
- **유효 주소**
  - 연산에 사용할 데이터가 저장된 위치
- 다섯가지 방식
  1. 즉시 주소 지정 방식 : 연산에 사용할 데이터
  2. 직접 주소 지정 방식 : 유효 주소(메모리 주소) 
  3. 간접 주소 지정 방식 : 유효 주소의 주소
  4. 레지스터 주소 지정 방식 : 유효 주소(레지스터 이름)
  5. 레지스터 간접 주소 지정 방식 : 유효 주소를 저장한 레지스터

### 좀 더 알아보기. 스택과 큐
- **스택(stack)**
  - 한쪽 끝이 막혀 있는 통과 같은 저장 공간
  - 한쪽 끝이 막혀 있어서 막혀있지 않은 쪽으로 데이터를 차곡차곡 저장하고, 저장한 자료를 빼낼 때는 마지막으로 저장한 데이터부터 빼낸다.
  - '나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출)'(= LIFO(Last In First Out))
  - **PUSH**
    - 스택에 새로운 데이터를 저장하는 명령어
  - **POP**
    - 스택에 저장된 데이터를 꺼내는 명령어
- **큐(queue)**
  - 스택과 달리 양쪽이 뚫려 있는 통과 같은 저장 공간
  - 한쪽으로는 데이터를 저장하고, 다른 한쪽으로는 먼저 저장한 순서대로 데이터를 빼낸다.
  - '가장 먼저 저장된 데이터부터 빼내는 관리 방식(선입선출)'(= FIFO(First In First Out))
---