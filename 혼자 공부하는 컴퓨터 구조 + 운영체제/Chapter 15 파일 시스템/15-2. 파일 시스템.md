# Chapter 15 파일 시스템
## 15-2. 파일 시스템
- 이번 절에서는 파일 시스템이 파일과 디렉터리를 보조기억장치에 어떻게 할당하고 접근하는지에 관한 이론적인 내용을 먼저 학습하고, 이러한 이론을 기반으로 만들어진 대표적인 파일 시스템 **FAT 파일 시스템과 유닉스 파일 시스템** 을 학습해보자.

### 파티셔닝과 포매팅
- 이제 막 공장에서 생산되어 한 번도 사용된 적이 없는 새 하드 디스크 또는 SSD가 있다고 가정하자.
  - 이 보조기억장치에서 곧바로 파일을 생성하거나 저장할 수 없다.
  - 왜냐하면 보조기억장치를 사용하려면 **파티션 을 나누는 작업(파티셔닝)과 포맷 작업(포매팅)** 을 거쳐야 하기 때문이다.
- **파티셔닝(partitioning)** 은 저장 장치의 논리적인 영역을 구획하는 작업을 의미한다.
  - 가령 엄청나게 커다란 서랍이 있다고 생각하자.
  - 커다란 서랍 안에 마구잡이로 물건들을 보관하면 필요한 물건을 정돈하는 게 쉽지 않다.
  - 하지만 서랍 안에 다음과 같이 칸막이를 설치하여 영역을 나누면 물건들을 정리하기가 조금 더 수월하다.
    - 이렇게 칸막이로 영역을 나누는 작업이 바로 **파티셔닝** 이다.
    - 하드 디스크나 SSD처럼 용량이 큰 저장 장치를 하나 이상의 논리적인 단위로 구획하는 것이다.
    - 그리고 이렇게 파티셔닝 작업을 통해 나누어진 영역 하나하나를 **파티션(partition)** 이라고 한다.
- 포맷하는 작업, 즉 **포매팅(formatting)** 은 저장 장치를 완전히 삭제하는 것으로 알고 있는 사람들이 많지만, 사실 이는 완벽하게 정확한 표현이라고 보기는 어렵다.
  - 포매팅이란 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업을 의미한다.
  - 즉, 어떤 종류의 파일 시스템을 사용할지는 바로 이때 결정난다.

### 파일 할당 방법
- 하드 디스크의 포매팅까지 끝냈다고 가정하자. 이제 이 저장 장치에 사용할 파일을 저장해보자.
  - 운영체제는 파일과 디렉터리를 **블록(block)** 단위로 읽고 쓴다.
  - 즉, 하나의 파일이 보조기억장치에 저장될 때는 하나 이상의 블록에 걸쳐 저장된다.
  - 하드 디스크의 가장 작은 저장 단위는 섹터이지만, 운영체제는 하나 이상의 섹터를 블록이라는 단위로 묶은 뒤 블록 단위로 파일과 디렉터리를 관리한다.
  - 파일 시스템이 모든 섹터를 관리하기에는 개수가 너무 많고 크기도 작기 때문이다.
- 파일을 보조기억장치에 할당하는 방법에는 크게 두 가지가 있다.
  - **연속 할당과 불연속 할당** 이다.
    - 불연속 할당에는 크게 **연결 할당, 색인 할당** 이 있다.

#### 연속 할당
- **연속 할당(contiguous allocation)** 은 가장 단순한 방식이다.
  - 이름 그대로 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식이다.
  - 가령 블록을 세 개, 두 개, 다섯 개 차지하는 정도의 크기를 가진 파일 a, b, c가 있을 때 이 파일들은 연속적으로 할당된다.
- 연속으로 할당된 파일에 접근하기 위해서는 파일의 첫 번째 블록 주소와 블록 단위의 길이만 알면 된다.
  - 그렇기에 연속 할당을 사용하는 파일 시스템에서는 다음과 같이 디렉터리 엔트리에 파일 이름과 더불어 첫 번째 블록 주소와 블록 단위의 길이를 명시한다.
- 연속 할당 방식은 파일을 그저 연속적으로 저장하는 방식이기에 구현이 단순하다는 장점이 있지만, **외부 단편화** 를 야기한다는 치명적인 문제가 있다.

#### 연결 할당
- 연속 할당의 문제를 해결할 수 있는 방식이 **연결 할당(linked allcation)** 이다.
  - 연결 할당은 각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식이다.
  - 즉, 파일을 이루는 데이터를 연결 리스트로 관리한다.
  - 연결 할당은 불연속 할당의 일종이기에 파일이 여러 블록에 흩어져 저장되어도 무방하다.
- 연결 할당은 외부 단편화 문제를 해결하지만 이 또한 단점이 있다.
  1. **반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 한다.**
    - 첫 번째 단점은 파일의 중간 부분부터 접근하고 싶어도 반드시 파일의 첫 번째 블록부터 접근하여 하나씩 차례대로 읽어야 한다는 점이다.
    - 다시 말해 파일 내 임의의 위치에 접근하는 속도, 즉 **임의 접근(random access)** 속도가 매우 느리다.
      - 예를 들어 i번째 블록에 접근하기 위해서는 반드시 첫 번째 블록부터 i번째 블록까지 일일이 순서대로 접근해야만 한다.
      - 이는 성능 면에서 상당히 비효율적이다.
  2. **하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다.**
    - 두 번째 단점은 하나의 블록 안에 파일 데이터와 다음 블록 주소가 모두 포함되어 있다 보니, 하드웨어 고장이나 오류로 인해 파일을 이루는 블록에 하나라도 문제가 발생하면 그 블록 이후의 블록에 접근할 수 없다는 것이다.
    - 하드 디스크는 굉장히 정교하고 고장에 예민한 장치이다.
    - 하드 디스크 헤드는 플래터 위에 대단히 미세한 간격으로 떨어져 있는 만큼 층격을 받으면 자칫 헤드가 플래터에 충돌하여 데이터를 손상 시킬 수 있다.
    - 그래서 오늘날에는 위 내용을 그대로 구현하기보다는 이를 조금 변형하여 사용한다.
      - 연결 할당을 변형한 대표적인 파일 시스템이 오늘날까지도 많이 사용하는 FAT 파일 시스템이다.

#### 색인 할당
- 연결 할당은 블록 일부에 다음 블록 주소를 표현하는 방식이다.
  - 반면, **색인 할당(indexed allocation)** 은 파일의 모든 블록 주소를 **색인 블록(index block)** 이라는 하나의 블록에 모아 관리하는 방식이다.
- 예를 들어 파일 a의 색인 블록은 4번 블록이고, 파일 a의 데이터는 7번, 13번, 11번 블록에 저장되어 있다고 가정하자.
  - 4번 블록 안에는 파일 a를 구성하는 블록들의 주소인 7, 13, 11이 적혀 있다.
  - 파일 a에 순차적으로 접근하고 싶다면 색인 블록에 저장된 주소에 차례대로 접근하면 된다.
- 색인 할당은 연결 할당과는 달리 파일 내 임의의 위치에 접근하기 쉽다.
  - 파일의 i번째 데이터 블록에 접근하고 싶다면 색인 블록의 i번째 항목이 가리키는 블록에 접근하면 되기 때문이다.
- 색인 블록 안에 파일을 구성하는 데이터 블록 주소가 있으므로 색인 블록만 알면 해당 파일 데이터에 접근할 수 있다.
  - 그렇기에 색인 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 더불어 **색인 블록 주소** 를 명시한다.
- 색일 할당을 기반으로 만든 파일 시스템이 유닉스 파일 시스템이다.

### 파일 시스템 살펴보기
- 다양한 파일 시스템이 있지만 여러 전공서에서 공통으로 소개하는 파일 시스템은 크게 두 가지이다.
  - 하나는 USB 메모리, SD 카드 등의 저용량 저장 장치에서 사용되는 **FAT 파일 시스템** 이고, 다른 하나는 유닉스 운영체제에서 사용되는 **유닉스 파일 시스템** 이다.
  
#### FAT 파일 시스템
- 연결 할당의 단점을 보완한 파일 시스템이 FAT 파일 시스템이다.
  - 앞서 설명한 연결 할당 방식에는 몇 가지 단점이 있는데 근본적인 원인은 블록 안에 다음 블록의 주소를 저장하였기 때문이다.
- 가령 파일 a가 네 개의 블록으로 이루어져 있고 a를 구성하는 데이터는 4, 8, 3, 5번 블록에 걸쳐 저장되었다고 가정하자.
  - 4번 블록이 8번 블록을 가리키고 있고, 8번 블록은 3번 블록을, 3번 블록은 5번 블록을 가리키고 있다.
  - 이런 방식은 임의 접근의 성능이 좋지 못하고, 이 블록들 중 하나라도 문제가 발생하면 그 이후의 블록에는 접근할 수 없다.
  - 하지만 각 블록에 포함된 다음 블록의 주소들을 한데 모아 테이블 형태로 관리하면 앞서 언급한 단점들을 상당 부분 해소할 수 있다.
    - 이러한 테이블을 **파일 할당 테이블(FAT: File Allocation Table)** 이라 부른다.
- 이렇게 FAT를 이용하는 파일 시스템이 바로 **FAT 파일 시스템** 이다.
- FAT 파일 시스템에서 FAT는 파티션의 앞부분에 만들어진다.
  - 하드 디스크의 한 파티션을 FAT 파일 시스템으로 포맷하면 해당 파티션이 다음과 같이 구성된다고 이해하면 된다.
  - FAT 영역에 FAT가 저장되고, 뒤이어 루트 디렉터리가 저장되는 영역이 있으며, 그 뒤에 서브 디렉터리와 파일들을 위한 영역이 있다.
    - 예약 영역 | FAT 영역 | 루트 디렉터리 영역 | 데이터 영역
- FAT는 하드 디스크 파티션의 시작 부분에 있지만, 실행하는 도중 FAT가 메모리에 캐시될 수 있다.
  - FAT가 메모리에 적재된 채 실행되면 기존 연결 할당보다 다음 블록은 찾는 속도가 매우 빨라지고, 결과적으로 앞서 설명한 연결 할당 방식보다 임의 접근에도 유리해진다.
  - 즉, FAT가 메모리에 적재된 채 실행하면 임의 접근의 성능이 개선된다.
- FAT 파일 시스템의 디렉터리 엔트리를 조금 더 자세히 살펴보자.
  - 앞서 FAT 파일 시스템의 디렉터리 엔트리에는 파일 이름과 더불어 파일의 첫 번째 블록 주소가 명시된다고 했다.
  - 이외에도 파일 시스템의 디렉터리 엔트리에는 파일 속성과 관련한 다양한 정보들이 있다.

#### 유닉스 파일 시스템
- 색인 할당 기반의 **유닉스 파일 시스템** 을 살펴보자.
  - 색인 할당은 색인 블록을 기반으로 파일의 데이터 블록들을 찾는 방식이라고 소개했다.
  - 유닉스 파일 시스템에서는 이 색인 블록을 **i-node(index-node)** 라고 부른다.
- i-node에는 파일 속성 정보와 열다섯 개의 블록 주소가 저장될 수 있다.
- 유닉스 파일 시스템에는 파일마다 이러한 i-node가 있고, i-node마다 번호가 부여되어 있다.
  - 그리고 i-node들은 파티션 내 특정 영역에 모여 있다.
  - i-node 영역에 i-node들이 있고, 데이터 영역에 디렉터리와 파일들이 있다.
- 그런데 여기 한 가지 문제가 있다.
  - i-node의 크기는 유한하다.
  - i-node 하나는 기본적으로 열다섯 개의 블록 주소를 저장할 수 있기 때문에 i-node 하나는 열다섯 개의 블록을 차지하는 파일까지 가리킬 수 있다.
  - 하지만 블록을 20개, 30개, 그 이상을 차지하는 큰 파일도 존재한다.
    - 이 경우 i-node 하나만으로는 파일의 데이터 블록을 모두 가리킬 수 없다.
    - 유닉스 파일 시스템은 이러한 문제를 다음과 같이 해결한다.
      1. **블록 주소 중 열두 개에는 직접 블록 주소를 저장한다.**
        - i-node가 가리킬 수 있는 열다섯 개의 블록 주소 중 처음 열두 개에는 파일 데이터가 저장된 블록 주소가 직접적으로 명시된다.
          - 파일 데이터가 저장된 블록을 **직접 블록(direct block)** 이라고 한다.
        - 즉, i-node의 열두 개 주소는 직접 블록 주소를 저장한다.
        - 이것만으로 파일 데이터 블록을 모두 가리킬 수 있다면 여기서 추가적인 작업이 필요하지 않다.
      2. **'첫째' 내용으로 충분하지 않다면 열세 번째 주소에 단일 간접 블록 주소를 저장한다.**
        - 열두 개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 열세 번째 블록 주소를 이용한다.
        - 열세 번째 블록 주소는 단일 간접 블록의 주소를 저장한다.
          - **단일 간접 블록(single indirect block)** 이란 파일 데이터가 저장된 블록이 아닌 파일 데이터를 저장한 브록 주소가 저장된 블록을 의미한다.
      3. **'둘째' 내용으로 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장한다.**
        - 열세 개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 열네 번째 블록 주소를 이용한다.
        - 열네 번째 블록 주소는 이중 간접 블록 주소를 저장한다.
          - **이중 간접 블록(double indirect block)** 이란 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록을 의미한다.
        - 즉, 단일 간접 블록들의 주소를 저장하는 블록이 이중 간접 블록이다.
      4. **'셋째' 내용으로 충분하지 않다면 열다섯 번째 주소에 삼중 간접 블록 주소를 저장한다.**
        - 열네 개의 블록 주소로 파일 블록을 가리킬 수 없다면 i-node의 열다섯 번째 블록 주소를 이용한다.
        - 열다섯 번째 블록 주소는 삼중 간접 블록 주소를 저장한다.
          - **삼중 간접 블록(triple indirect block)** 이란 이중 간접 블록 주소가 저장된 블록이다.
        - 삼중 간접 블록까지 이용하면 웬만한 크기의 파일은 모두 표현할 수 있다.
      
> #### 좀 더 알아보기) 저널링 파일 시스템
> - 컴퓨터를 이용해 작업을 하던 도중 갑자기 전원이 나가거나 치명적인 오류로 인해 컴퓨터가 강제로 종료되어 버린 상황을 가정해보자.
>   - 파일 시스템을 변경하는 도중에 이러한 상황(**시스템 크래시**)이 발생하면 파일 시스템이 훼손될 수 있다.
> - 저널링 파일 시스템이 있기 전에는 이런 상황이 발생하면 부팅 직후 파일 시스템을 검사하고 복구하는 프로그램을 실행시켰다.
>   - 유닉스나 리눅스의 fsck나 윈도우의 scandisk가 이러한 프로그램에 속한다.
>   - 다만 이러한 프로그램들은 파일 시스템 내의 모든 블록에 대해 파일 시스템을 검사하기 때문에 시간이 매우 오래 걸린다는 문제가 있다.
> - 그래서 등장한 것이 저널링 기법을 이용하는 **저널링 파일 시스템** 이다.
>   - **저널링(journaling) 기법** 이란 작업 로그를 통해 시스템 크래시가 발생했을 때 빠르게 복구하기 위한 방법이다.
>   - 저널링 기법을 사용하는 파일 시스템에서 파일 시스템을 변경하는 작업은 다음과 같은 순서로 수행된다.
>     1. 작업 직전 파티션의 로그 영역에 수행하는 작업(변경 사항)에 대한 로그를 남긴다.
>     2. 로그를 남긴 후 작업을 수행한다.
>     3. 작업이 끝났다면 로그를 삭제한다.
>   - 이 경우 만약 작업을 하던 도중 시스템 크래시가 발생하여 다시 부팅을 해야 한다면 파일 시스템 전체를 검사할 필요 없이 로그 영역에 남긴 로그만 검새해도 된다.
>     - 즉, 저널링 파일 시스템은 시스템 크래시가 발생한 직후에 로그 영역을 읽어 크래시가 발생한 당시 어떤 작업을 실행 중이었는지 알아낸 다음 해당 작업을 완료한다.

> #### 마운트
> - 유닉스, 리눅스 등의 운영체제에서 '저장 장치를 마운트한다'라는 표현을 자주 사용한다.
>   - 이는 한 저장 장치의 파일 시스템에서 다른 저장 장치의 파일 시스템에 접근할 수 있도록 파일 시스템을 편입 시키는 작업을 의미한다.
> - 유닉스, 리눅스와 같은 운영체제에서 다양한 저장 장치를 컴퓨터에 연결할 때 mount 명령어로 빈번하게 마운트한다.

---