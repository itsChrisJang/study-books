# Chapter 1. 성능과 최적화
자바 성능을 최적화하는 일은 마치 어둠의 마법처럼 느껴집니다.   
흔히 성능 분석이라 하면 '홀로 고뇌하며 깊은 생각에 빠져 살아가는 고독한 해커'나 할 수 있는 고도의 숙력된 기술처럼 바라봅니다.   

안타깝게도 성능이 소프트웨어 팀의 부차적인 관심사인 상황과 맞물려 있습니다.   
그렇기에 시스템이 결딴나는 지경에 이르러서야 부랴부랴 분석 작업을 해보고 성능 '해결사'에게 구원의 손길을 뻗는 시나리오를 당연하게 생각하는데, 이는 현실과 조금 다릅니다.

실제로 성능 분석은 경험주의와 질퍽한 인간 심리학이 교묘히 어우러진 분야입니다.   
그리고 정작 중요한 건, 관측 지표의 절대 수치, 그리고 엔드 유저(최종 사용자, 실제로 시스템을 사용하는 사람)와 기타 이해관계자들이 그 수치를 어떻게 받아들이는가 하는 점입니다.

## 1.1 자바 성능: 잘못된 방법
자바 초창기에 메서드 디스패치 성능은 정말 최악이었습니다.   
그래서 메서드를 잘게 나누지 말고 하나의 덩치 큰 메서드로 장ㄱ성하는 게 좋다고 권고하는 개발자가 있었는데, 시간이 지나면서 가상 디스패치 성능은 엄청나게 좋아졌고, 특히 최신 자바 가상 머신에서는 자동 인라이닝 덕분에 가상 디스패치조차 대부분의 호출부(콜 사이트)에서 사라지게 되었습니다.   
**'모든 코드를 한 메서드에 욱여넣어라'** 는 말대로 짠 코드는 바야흐로 현대 JIT 컴파일러와는 어울리지 않는 퇴물이 되었습니다.

정량적, 검증 가능한 방식으로 성능을 다루지 않으면 얼마나 안 좋지 영향을 끼칠 수 있는지 깨닫게 되었습니다.

- 우수한 성능 목표 달성을 위해 필요한 단면
  - 전체 소프트웨어 수명주기의 성능 방법론
  - 성능과 연관된 테스트 이론
  - 측정, 통계, 툴링
  - (시스템 + 데이터) 분석 스킬
  - 하부 기술과 메커니즘(장치, 수단)

- 일반적인 원칙
  - JVM을 더 빨리 작동시키는 '마법의 스위치' 같은 건 없습니다.
  - 자바를 더 빨리 실행하게 만드는 '팁, 트릭'은 없습니다.
  - '비밀 알고리즘'도 없습니다.

## 1.2 자바 성능 개요
> 자바는 블루 컬러 언어입니다. 박사 학위 논문 주제가 아니라 일을 하려고 만든 언어죠.

자바는 처음부터 지극히 실용적인 언어였습니다.   
개발 환경이 충분히 빠르다면 개발자 생산성이 높아지는 대가로 어느 정도의 성능 희생은 감수할 만한다는 입장입니다.   
그러나 자바 환경이 고성능 컴퓨팅 애플리케잉션에 적합한 수준에 이른 건 비교적 최근에 핫스팟 같은 정교한 JVM이 성숙했기 때문입니다.

실용성을 추구하는 자바 플랫폼에 성격에는 서비 시스템이 가장 대표적인데, 이 개념은 개발자가 일일이 용량을 세세하게 관리하는 부담을 덜어주고, 대신 저수준으로 제어 가능한 일부 기능을 포기하자는 발상입니다.   
단적으로 메모리 관리가 그렇듯이, JVM이 탈착형 가비지 수집 서브시스템 형태로 메모리를 자동 관리하는 덕분에 프로그래머는 수동으로 메모리를 의식하며 개발할 필요가 없습니다.

JVM 애플리케이션의 성능 측정값은 정규 분포를 따르지 않는 경우가 많아서 기초 통계 기법(예: 표준편차, 분산)만 갖고는 측정 결과를 제대로 처리하기 역부족입니다.   
쉬운 예로 JVM 애플리케이션에서 특이점은 매우 중요한 의미를 내포하고, 즉 측정값을 샘플링하면 특이점을 일으킨 가장 중요한 이벤트가 묻혀버릴 가능성이 큽니다.

## 1.3 성능은 실험과학이다.
자신이 처한 한경에 적응하며 고도로 최적화하는 JVM을 기반으로 구축된 운영 시스템의 성능 양상은 상당히 미묘하고 복잡하게 나타날 수 있습니다.   
이렇게 복잡한 지경까지 이른 건 무어의 법칙과 그로 인한 하드웨어 용량의 전무후무한 발전 떄문입니다.

JVM 성능 튜닝은 기술, 방법론, 정량적 측정값, 툴을 망라한 개념입니다.   
그 목표는 시스템 소유자/유저가 추구하는 측정 결과를 얻는 것이고, 즉 성능은 아래와 같은 활동을 하면서 원하는 결과를 얻기 위한 일종의 실험과학이락 할 수 있습니다.
- 원하는 결과를 정의한다.
- 기존 시스템을 측정한다.
- 요건을 측정시키려면 무슨 일을 해야 할지 정한다.
- 개선 활동을 추진한다.
- 다시 테스트한다.
- 목표가 달성됐는지 판단한다.

바람직한 성능 결과를 정의하고 판단하는 과정에서 정량적인 일련의 목표가 수립됩니다.   
무엇을 측정할지 대상을 확정하고 목표를 기록하는 행위가 중요한데, 결국 이런 활동들이 프로젝트 아티팩트와 제품 일부를 형성하고 성능 분석은 비기능 요건을 정의하고 달성하는 활동입니다.

즉, **성능 분석은 닭을 해부하는 과정이 아닌, 통계치에 근거해 적절히 결과를 처리하는 활동**입니다.

## 1.4 성능 분류
성능 지표는 튜닝 프로젝트의 목표를 정량적인 단위로 표현한 기준입니다.

### 1.4.1 처리율(throughput)
처리율은 서브 시스템이 수행 가능한 작업 비율을 나타낸 지표로 보통 일정 시간 동안 완료한 작업 단위 수로 표시합니다.(예 : 초당 처리 가능한 트랜잭션 수)

처리율이 실제 성능을 반영하는 의미 있는 지표가 되려면 수치를 얻은 기준 플랫폼에 대해서도 내용을 기술해야 합니다.    
그리고 트랜잭션은 테스트 할 떄 마다 동일해야 합니다.   
처리율을 테스트할 때 실행 간 워크로드 역시 일정하게 유지해야 합니다.

### 1.4.2 지연(latency)
성능 지표는 수도 배관에 빗대어 설명할 때가 많습니다.   
1초에 100리터를 흘려보내는 수도관의 처리율은 바로 1초에 처리되는 부피(100리터)입니다.   
이때 **지연(latency)은 수도관 자체의 길이에 해당**합니다.   
즉, 하나의 트랜잭션을 처리하고 그 결과를 반대편 수도관 끝에서 바라볼 때 까지 소요된 시간입니다.

지연을 종단 시간이라고도 하며, 대개 그래프에서 워크로드에 비례하는 함수로 표시합니다.

### 1.4.3 용량(capacity)
용량은 시스템이 보유한 작업 병렬성의 총량, 즉 시스템이 동시 처리 가능한 작업 단위(즉, 트랜잭션) 개수를 의미합니다.  

용량은 처리율과 밀접한 관계가 있습니다.   
시스템이 동시 부하가 증가할수록 처리율(그리고 지연)도 영향을 받습니다.   
이런 이유로 보통 용량은 어떤 처리율 또는 지연 값을 전제로 가능한 처리량으로 표시합니다.

### 1.4.4 사용률(utilization)
성능 분석 업무 중 가장 흔한 태스크는 시스템 리소스를 효율적으로 활용하는 겁니다.   
가령, CPU 라는 리소스는 놀리는(또는 OS에 시간을 빼앗기거나 다른 관리 태스크를 수행하는) 것 보다 실제 작업 단위를 처리하는 데 쓰여야 한다.

사용률은 워크로드에 따라서 리소스별로 들쑥날쑥할 수 있습니다.   
이를테면, 계산 집약적 워크로드를 주면 CPU 사용률은 100%에 육박하지만, 메모리 사용률은 얼마 안 나옵니다.

### 1.4.5 효율(efficiency)
전세 시스템의 효율은 처리율을 리소스 사용률로 나눈 값으로 측정합니다.      
같은 처리율을 더 많은 리소스를 쏟아부어야 달성할 수 있다면 효율이 낮은 것 입니다.

### 1.4.6 확장성
처리율이나 시스템 용량은 처리하는 데 끌어 쓸 수 있는 리소스에 달려 있습니다.   
리로스 추가에 따른 처리율 변화는 시스템/애플리케이션의 확장성을 가늠하는 척도입니다.   
시스템 확정성은 궁극적으로 정확히 리소스를 투입할 만틈 처리율이 변경되는 형태를 지향합니다.

### 1.4.7 저하
요청(또는 클라이언트) 개수가 증가하건, 요청 접수 속도가 증가하건, 어떤 형태로든 시스템이 더 많은 부하를 받으면 지연 그리고/또는 처리율 측정값에 변화가 생깁니다.

시스템을 덜 사용하고 있으면 측정값이 느슨하게 변하지만, 시스템이 풀 가동된 상태면 처리율이 더는 늘어나지 않는, 즉 지연이 증가하는 양상을 띱니다.   
이런 현상을 부하 증가에 따른 저하라고 합니다.

### 1.4.8 측정값 사이의 연관 관계
다양한 성능 측정값ㅅ은 어떤 식으로든 서로 연결돼 있습니다.   
또 구체적인 상호 관계는 시스템이 풀 가동 중인지 여부에 따라 달라집니다.   

## 1.5 성능 그래프 읽기
![성능 엘보](Documents/study/study-books/자바 최적화/imageents/study/study-books/자바 최적화/image/performance_elbow.png)
부하가 증가하면서 예기치 않게 저하(지연)가 발생한 그래프입니다.   
이런 형태를 보통 성능 엘보라고 합니다.

![준-선형적 확장](Documents/study/study-books/자바 최적화/imageents/study/study-books/자바 최적화/image/near_linear_extenstion.png)
위와 반대로 클러스터에 장비를 추가함에 따라 선형적으로 처리율이 확장되는 아주 운이 좋은 케이스입니다.   
이렇게 이상적인 모습에 가까운 결과는 환경이 극단적으로 순조로울 때(예: 서버 하나에 세션 어피니티(세션 고정)가 필요없는, 무상태 프로토콜을 확장하는 경우)나 가능합니다.

![암달의 법칙](Documents/study/study-books/자바 최적화/imageents/study/study-books/자바 최적화/image/amdahl_law.png)
암달에 따르면 근본적으로 확장성에는 제약이 따릅니다.   
아래 그래프는 태스크를 처리할 때 프로세서 개수를 늘려도 실행 속도를 최대 어느 정도까지 높일 수 있는지를 나타낸 그래프입니다.

하부 태스크를 75%, 90%, 95% 세 가지 다른 비율로 병렬화했는데, 그래프를 잘 보면 워크 로드에 반드시 순차 실행되어야 할 작업 조각이 하나라도 있으면 선형 확장은 처음부터 불가하며 확장 가능한 한계점도 뚜렷하다는 사실을 알 수 있습니다.

![건강한 메모리 사용 현황](Documents/study/study-books/자바 최적화/imageents/study/study-books/자바 최적화/image/well_used_memory_usage.png)
JVM 가비지 수집 서브시스템의 메모리 사용 패턴은 그 하부 기술 때문에 부하가 별로 없는 건강한 애플리케이션도 톱니 모양을 나타냅니다.

![문제가 있는 할당률 뷴포](Documents/study/study-books/자바 최적화/imageents/study/study-books/자바 최적화/image/problematic_allocation_rate_distribution.png)
피보나치 수열을 계산하는 애플리케이션을 실행하여 얻은 그래프로, 애플리케잉션의 메모리 할당률을 성능 튜닝할 때 아주 중요한 메모리 그래프입니다.

동일한 툴로 측정한 다른 그래프를 보면, 바로 이 지점에서 애플리케이션에 심각한 가비지 수집 문제가 발생했고 가비지 수집 스레드들이 서로 CPU 경합을 벌인 탓에 메모리를 충분히 할당받지 못했다는 사실을 알 수 있습니다.

![부하가 높을 때 상당한 지연 발생](Documents/study/study-books/자바 최적화/imageents/study/study-books/자바 최적화/image/significant_delay_under_high_load.png)
위 그림은 시스템 리소스가 누수될 때 흔히 나타나는 징후입니다.   
부하가 증가하면서 지표가 차츰 악화되다가 결국 시스템 성능이 급락하는 변곡점에 이르게 됩니다.