# Chapter 2. JVM 이야기

성능에 관심 있는 개발자라면 기본적인 JVM 기술 스택의 구조를 이해해야 합니다.   
JVM 기술을 이해하면 더 좋은 소프트웨어를 개발할 수 있고 성능 이슈를 탐구할 때 필요한 이론적 배경지식을 갖추게 됩니다.

## 2.1 인터프리팅과 클래스로딩
자가 가상 머신을 규정한 명세서에 따르면 JVM은 스택 기반의 해석 머신입니다.   
레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 이 스택의 맨 위에 쌓인 값을 가져와 계산을 합니다.

JVM 인터르피터의 기본 로직은 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 옵코드를 하나씩 순서대로 처리하는 'while 루프 안의 switch문'입니다.

java HelloWorld 명령을 내려 자바 애플리케이션을 실행하면 OS는 가상 머신 프로세스(자바 바이너리)를 구동합니다.   
자바 가상 환경이 구성되고 스택 머신이 초기화된 다음, 실제로 유저가 작성한 HelloWolrd 클래스 파일이 실행됩니다.

우리도 알다시피 애플리케이션의 진입점은 HelloWorld.class에 있는 main() 메서드입니다.   
제어권을 이 클래스로 넘기려면 가상 머신이 실행이 되기 전에 이 클래스를 로드해야 합니다.

여기서 자바 클래스로딩 매커니즘이 관여합니다.   
자바 프로세스가 새로 초기화되면 사슬처럼 줄지어 연결된 클래스로더가 차례차례 작동합니다.   
제일 먼저 부트스트랩 클래스가 기지개를 켜며 자바 런타임 코어 클래스를 로드합니다.   
런타임 코어 클래스는 자바 8 이전까지는 rt.jar 파일에서 가져오지만, 자바 9 이후부터는 런타임이 모듈화되고 클래스로딩 개념 자체가 많이 달라졌습니다.

부트스트랩 클래스로더의 주 임무는 다른 클래스로더가 나머지 시스템에 필요한 클래스를 로드할 수 있게 최소환의 필수 클래스만 로드하는 것입니다.

그 다음, 확장 클래스로더가 생깁니다.   
부트스트랩 클래스로더를 자기 부모로 설정하고 필요할 때 클래스로딩 작업을 부모에게 넘깁니다.

끝으로, 애플리케이션 클래스로더가 생성되고 지정된 클래스패스에 위치한 유저 클래스를 로드합니다.

자바는 프로글매 실행 중 처음 보는 새 클래스를 디펜던시(dependency)에 로드합니다.   
클래스를 찾지 못한 클래스로더는 기본적으로 자신의 부모 클래스로더에게 대신 룩업을 넘깁니다.   

보통 환경에서는 자바는 클래스를 로드할 때 런타임 환경에서 해당 클래스를 나타내는 Class 객체를 만듭니다.

## 2.2 바이트코드 실행
자바 소스 코드는 실행되기까지 꽤 많은 변환 과정을 거칩니다.   
첫 단계는 자바 컴파일러 javac를 이용해 컴파일하는 것으로, 보통 전체 빌드 프로세스의 한 부분으로 수행합니다.   

![자바 소스 코드를 컴파일해서 클래스 파일을 만듦](image/compiling_java_source_to_class_file.png)
javac가 하는 일은 자바 소스 코드를 바이트코드로 가득 찬 .class 파일로 바꾸는 겁니다.   
위 그림애서 보다시피 소스 코드 번역 작업은 매우 간단합니다.   
javac는 컴파일하는 동안 최적화는 거의 하지 않기 때문에 그 결과로 생성된 바이트코드는 쉽게 해독할 수 있습니다.

바이트코드는 특정 컴퓨터 아키텍처에 특정하지 않은 **중간 표현형(IR : ntermediate Representation)** 입니다.   
컴퓨터 아키텍처의 지배를 받지 않으므로 이식성이 좋아 개발을 마친(즉, 컴파일된) 소프트웨어는 JVM 지원 플랫폼 어디서건 실행할 수 있고 자바 언어에 대해서도 추상화되어 있습니다.

컴파일러가 생성한 클래스 파일은 VM 명세서에 아주 명확히 잘 정의된 구조(아래 그림)를 갖추고 있습니다.
![클래스 파일 해부도](image/class_file_anatomy.png)
