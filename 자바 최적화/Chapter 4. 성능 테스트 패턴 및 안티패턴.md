# Chapter 4. 성능 테스트 패턴 및 안티패턴

다양한 종류의 테스트를 소개하고 유형별 베스트 프랙티스를 공부해보겠습니다.

## 4.1 성능 테스트 유형
성능 테스트를 나쁜 의도로, 부실하게 수행하는 경우가 많습니다.    
원인은 제각각이겠지만 대개 성능 분석의 본질을 이해하지 못한 채 "그래도 뭐라도 하는 게 아무것도 안 하는 것보단 낫지 않나"라고 믿기 때문입니다.

가장 흔히 저지르는 실수는 구체적인 내용을 정하지 않고 뭉뚱그려 '성능 테스트'를 운운하는 겁니다.

성능 테스트는 유형별로 그 목표가 거의 독립적(약간 중첩되는 부분도 있지만)입니다.

- 지연 테스트(Latency test)
  - 종단 트랜잭션에 걸리는 시간은?
- 처리율 테스트(Throughput test)
  - 현재 시스템이 처리 가능한 동시 트랜잭션 개수는?
- 부하 테스트(Load test)
  - 특정 부하를 시스템이 감당할 수 있는가?
- 스트레스 테스트(Stress test)
  - 이 시스템의 한계점은 어디까지인가?
- 내구성 테스트(Endurance test)
  - 시스템을 장시간 실행할 경우 성능 이상 증상이 나타나는가?
- 용량 계획 테스트(Capacity planning test)
  - 리소스를 추가한 만큼 시스템이 확장되는가?
- 저하 테스트(Degradation)
  - 시스템이 부분적으로 실패할 경우 어떤 일이 벌어지나?

### 4.1.1 지연 테스트(Latency test)
지연 테스트는 가장 일반적인 성능 테스트입니다.    
'고객이 트랜잭션(또는 페이지 로딩)'을 얼마나 오래 참고 기다려야 하는지' 측정한 시스템 수치는 경영진들이 피부로 느끼는 관심사입니다.   
이 테스트를 통해 답변하려는 질문이 너무 정량적이고 명확한 나머지 다른 종류의 성능 테스트로 밝히려는 정량적 질문을 식별한 필요성마저 흐릿하게 만들 수 있습니다.

그러나 아무리 단순한 케이스라도 지연 테스트에는 조심스럽게 취급해야 할 미묘한 부분이 있습니다.    
단순 평균값은 애플리케이션의 요청 응답성을 측정하는 지표로 별로 소용이 없다는 사실도 주의해야 합니다.

### 4.1.2 처리율 테스트(Throughput test)
처리율 테스트는 그다음으로 일반적인 성능 테스트입니다.   
어떤 측면에서 처리율은 지연과 동등한 개념이라고 볼 수 있습니다.

이를테면, 지연 테스트를 수행할 때에는 계속 진행 중인 동시 트랜잭션을 반드시 명시(그리고 제어)해야 합니다.

마찬가지로, 처리율 역시 지연을 모니터링하면서 테스트합니다.   
지연 분포가 갑자기 변하는 점, 즉 사실상 한계점(변곡점)이 바로 '최대 처리율'입니다.   
스트레스 테스트의 목표는 이런 현상이 발생하는 지점과 그 시점의 부하 수준을 포착하는 것입니다.

반면, 처리율 테스트는 시스템 성능이 급락하기 직전, 최대 처리율 수치를 측정하는 것이 목표입니다.

### 4.1.3 부하 테스트(Load test)
부하 테스트는 처리율 테스트(또는 스트레스 테스트)와는 조금 다릅니다.   
'시스템이 이 정도 부하를 견딜 수 있을까?, 없을까?' 하는 예/아니오 질문에 답을 구하는 과정입니다.

가령 신규 고객을 유치하거나 새로운 시장에 진출하기 전, 애플리케이션 트래픽이 상당할 것으로 예상되는 특정 비즈니스 이벤트에 대비하기 위해 부하 테스트를 수행합니다.

### 4.1.4 스트레스 테스트(Stress test)
스트레스 테스트는 시스템 여력이 어느 정도인지 알아보는 수단입니다.     
보통 일정한 수준의 트랜잭션, 즉 특정 처리율(현재로서 최대치)을 시스템에 계속 걸어놓습니다.   

측정값이 나빠지기 시작하기 직전의 값이 바로 최대 처리율입니다.

### 4.1.5 내구성 테스트(Endurance test)
메모리 누수, 캐시 오염, 메모리 단편화(CMS 가비지 수집기를 쓰는 애플리케이션은 결국 언젠가 CMF가 발생합니다.) 등 한참 시간이 지나고 나서야 드러나는 문제점도 있습니다.

대개 이런 종류의 문제는 내구 테스트로 감지합니다.

평균 사융률로 시스템에 일정 부하를 계속 주며 모니터링하다가 갑자기 리소스가 고갈되거나 시스템이 깨지는 지점을 찾습니다.

내구 테스트는 빠른 응답을 요구하는 시스템에서 많이 합니다.    
풀 GC 사이클이 일으키는 STW 시간조차 허용되지 않습니다.

### 4.1.6 용량 계획 테스트(Capacity planning test)
용량 계획 테스트는 스트레스 테스트와 여러므로 비슷하지만, 분명히 구분되는 차이점이 있습니다.    
스트레스 테스트는 현재 시스템이 어느 정도 부하를 버틸 수 있는지 알아보는 반면, 용량 계획 테스트는 업그레이드한 시스템이 어느 정도 부하를 감당할 수 있을지 미리 내다보는 것입니다.

따라서 어떤 이벤트나 위협 요소에 대응하는 것이 아니라, 예정된 계획의 일부분으로 실행하는 경우가 많습니다.

### 4.1.7 저하 테스트(Degradation)
저하 테스트는 부분 실패 리스트라고도 합니다.   

이 책에서 저하 테스트는 복원 테스트 하나만 생각하면 됩니다.   
저하 테스트는 기본적으로 평상시 운영 환경과 동등한 수준의 부하를 시스템에 가하는 도중, 어떤 컴포넌트나 전체 서브시스템이 갑자기 능력을 상실하는 시점에 벌어지는 일들을 확인합니다.   
예를 들어, 애플리케이션 서버 클러스터에서 순간적으로 멤버가 사라지거나, DB 서버에서 RAID 디스크가 빠져버리든지, 네트워크 대역폭이 갑자기 줄어드는 경우를 떠올려볼 수 있습니다. 

저하 테스트 도중 눈여겨 봐야 할 측정값은 트랜잭션 지연 분포와 처리율입니다.

부분 실패 테스트 중에는 카오스 멍키(혼돈의 원숭이)라는 하위 유형이 있습니다.    
카오스 멍키의 요지는, 진짜 복원성 있는 아키텍처에서는 어느 한 컴포넌트가 잘못돼도 다른 컴포넌트까지 연쇄적으로 무너뜨리면서 전체 시스템에 부정적 영향을 끼치는 일은 없어야 한다는 것입니다.

### 4.2 기본 베스트 프랙티스
성능 튜닝시 주안점을 두어야 할 부분은 다음 세 가지 기본 원칙에 따라 결정합니다.
- 나의 관심사가 무엇인지 식별하고 그 측정 방법을 고민한다.
- 최적화하기 용이한 부분이 아니라, 중요한 부분을 최적화한다.
- 중요한 관심사를 먼저 다룬다.

두 번째 원칙을 반대로 바꿔보면, 쉽게 측정 가능한 양에 큰 의미를 부여하는 실수는 저지르지 말라는 뜻입니다.   
모든 측정 값이 다 비즈니스에 중요한 건 아니지만 정확하게 측정하기보다 쉽게 측정 가능한 것 위주로 보고서를 작성하려는 유혹에 빠지기 쉽습니다.

### 4.2.1 하향식 성능 
자바 성능을 다루는 엔지니어가 흔히 간과하는 사실이 있습니다.   
자바 애플리케이션은 대규모 벤치마킹하는 일이 작은 코드 섹션별로 정확하게 수치를 얻는 것보다 쉽다는 사실입니다.

하향식 성능 접근 방식으로 성과를 극대화하려면, 먼제 테스트팀이 테스트 환경을 구축한 다음, 무엇을 측정하고 무엇을 최적화해야 하는지, 또 성능 활동을 전체 소프트웨어 개발 주기에서 어떻게 병행해야 하는지, 전 팀원이 명확하게 이해해야 합니다.

### 4.2.2 테스트 환경 구축
테스트 환경 구축은 성능 테스트팀이 가장 먼저 할 일입니다.   
테스트 환경은 가급적 모든 면에서 운영 환경과 똑같이 복제해야 합니다.    
애플리케이션 서버뿐만 아니라(CPU 수, OS, 자바 런타임 버전도 같아야 함) 웹서버, DB, 로드 밸런서, 네트워크 방화벽 등도 맞추어야 합니다.    
운용 중인 각종 서비스(예: 복제하기 곤란하거나 운영 환경과 동등한 부하를 처리하기엔 QA 용량이 녹록치 않은 서드파티 네트워크 서비스)도 성능 테스트 환경에 목업 형태로 반영돼야 합니다.

운영 환경이 반영되지 않은 QA 호나경에서 성능 테스트하는 리스크가 얼마나 큰지는 모른 채, 성능 테스트 환경을 대충 만들어서라도 비용을 아끼는 게 더 중요하다고 믿는 경향이 있습니다.

최근에는 클라우드 기술의 출현으로 기존 판도가 많이 바뀌었습니다.    
주문형 및 자동 확장 인프라 기술이 발전해서 이제는 '서버를 사고, 네트워크 다이어그램을 그리고, 소프트웨어를 하드웨어에 배포하는' 공식에 안 맞는 아키텍처가 증가하는 추세입니다.

### 4.2.3 성능 요건 식별
성능을 평가하는 지표는 코드 관점에서만 생각해서도 안되고, 시스템을 전체적으로 바라보며 고객과 경영진에게 중요한 측정값을 고려해야 합니다.   
이렇게 최적화하려는 핵심 지표를 성능 비기능 요건이라고 합니다.

### 4.2.4 자바의 특정 이슈
성능 분석이라는 과학은 최신 소프트웨어 시스템의 어디에도 적용할 수 있습니다.   
하지만 JVM에는 성능 엔지니어가 잘 이해하고 주의 깊게 살펴야 할 복잡 미묘한 부분들이 있습니다.    
메모리 영역의 동적 튜닝 등 JVM 특유의 다이내믹한 자기 관리 기능이 추가되면서 복잡해진 까닭입니다.

특히 JIT 컴파일은 중요한 부분이라서 유심히 잘 살펴야 합니다.   
최신 JVM은 어떤 메서드를 JIT 컴파일해서 최적화한 기계어로 변환할지 분석합니다.   
JIT 컴파일 안 하기로 결정된 메서드는 다음 둘 중 하나입니다.
- JIT 컴파일할 정도로 자주 실행되는 메서드가 아니라.
- 메서드가 너무 크고 복잡해서 도저히 컴파일 분석을 할 수 없다.

첫 번째 조건보다 두 번째 조건이 훨씬 드문 편이지만, 어쨋든 JVM 기반 애플리케이션에서 성능 활동을 시작하는 첫 단추는, 어떤 메서드가 컴파일 중인지 로그를 남겨 살피고 핵심 코드 경로상의 중요 메서드가 잘 컴파일되고 있는지 확인하는 것입니다.

### 4.2.5 SDLC 일부로 성능 테스트 수행하기
성능 테스트는 그냥 생각날 때 한번 실행하는 게 낫다고 말하는 사람이 있습니다.    
그러나 일류 회사, 수준 높은 팀일수록 성능 테스트를 전체 SDLC(Software Development LifeCycle/소프트웨어 개발 수명주기)의 일부로서 수행하며, 특히 성능 회귀 테스트를 상시 수행하는 편입니다.

## 4.3 성능 안티패턴 개요
안티패턴은 사람들이 수많은 프로젝트를 수행하면서 밝혀낸, 소프트웨어 프로젝트 또는 팀의 좋지 않은 패턴입니다.    
발생 빈도가 늘어나면서 이러저러한 근본 요인 때문에 안 좋은 방향으로 흘러가는구나, 하고 결론을 내린겁니다.    

성능 튜닝은 항상 초기 기획 단계부터 구체적으로 목표를 정해놓고 시작하는 목표 지향형 프로세스로 접근해야 합니다.

### 4.3.1 지루함
개발자는 대부분 자기 역할에 지루함을 느끼고 뭔가 새롭고 도전적인 일을 찾아 같은 회사 또는 아예 다른 곳으로 떠날 궁리를 하는 사람도 있지만, 사내에 딱히 마땅한 기회가 없거나 다른 회사로 이직하는 게 여의치 않은 경우도 있습니다.

### 4.3.2 이력서 부풀리기
개발자의 지루함, 이력서 부풀리기 탓에 불필요한 기술을 자꾸 덧댄 결과는, 기존의 개발자가 더 좋은 회사로 이직한 후 아주 오랫동안 시스템에 지대한 영향을 미치게 됩니다.

### 4.3.3 또래 압박
서로 충분한 논의 없이 기술 결정을 하면 쓰디쓴 결과를 맛보기 쉽습니다.

### 4.3.4 이해 부족
지금 사용하는 툴의 기능도 온전히 알지 못하는데 무턱대고 새로운 툴로 문제를 해결하려는 개발자가 있습니다.

### 4.3.5 오해와 있지도 않은 문제
문제 자체가 무엇인지 제대로 이해하지 못한 채 오로지 기술을 이용해서 문제를 해결하려는 개발자도 있습니다.    
설령 그렇게 해서 성공한들, 성능 수치를 측정도 안 해보고 어떻게 성공을 장담할 수 있을까요?    
성능 지표를 수집/분석해야만 비로소 문제의 본질을 정확히 이해할 수 있습니다.

## 4.4 성능 안티패턴 카탈로그
### 4.4.1 화려함에 사로잡히다
#### 증상 
일단 최신의 멋진 기술을 튜닝 타깃으로 정합니다.    
레거시 코드를 파헤치느니 신기술의 작동 원리를 연구하는 게 더 재미있고, 또 아무래도 최신 기술이 더 멋진 코드로 구현됐고 관리하기는 쉽습니다.    
그리하여 개발자는 새로 나온 애플리케이션 컴포넌트를 찾아 헤매는 강박에 사로잡힙니다. 
#### 흔히 하는 말 
> 처음이라 말썽이 많군. 뭐가 문제인지 원인을 밝혀야 해.
#### 현실
#### 진단
#### 처방

### 4.4.2 단순함에사로잡히다
#### 증상
#### 흔히 하는 말
#### 현실
#### 진단
#### 처방

### 4.4. 사로잡히다
#### 증상
#### 흔히 하는 말
#### 현실
#### 진단
#### 처방